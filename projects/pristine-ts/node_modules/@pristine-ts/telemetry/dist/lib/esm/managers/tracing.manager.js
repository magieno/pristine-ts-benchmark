var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { injectable, scoped, Lifecycle, injectAll, inject } from "tsyringe";
import { Trace } from "../models/trace.model";
import { Span } from "../models/span.model";
import { moduleScoped, tag, ServiceDefinitionTagEnum, TracingContext } from "@pristine-ts/common";
import { SpanKeynameEnum } from "../enums/span-keyname.enum";
import { TelemetryModuleKeyname } from "../telemetry.module.keyname";
/**
 * The Tracing Manager provides methods to help with tracing.
 * It is tagged and can be injected using TracingManagerInterface which facilitates mocking.
 * It is module scoped to the TelemetryModuleKeyname.
 */
let TracingManager = class TracingManager {
    /**
     * The Tracing Manager provides methods to help with tracing.
     * It is tagged and can be injected using TracingManagerInterface which facilitates mocking.
     * It is module scoped to the TelemetryModuleKeyname.
     * @param tracers The tracers to use. All services tagged with ServiceDefinitionTagEnum.Tracer will be injected here.
     * @param loghandler The log handler to output logs.
     * @param isActive Whether or not tracing is activated.
     * @param debug Whether or not tracing is in debug mode, meaning that it should output logs with the debug severity about the trace and spans.
     * This can be set to false to prevent having to much logs for every single span created.
     * @param tracingContext The tracing context.
     */
    constructor(tracers, loghandler, isActive, debug, tracingContext) {
        this.tracers = tracers;
        this.loghandler = loghandler;
        this.isActive = isActive;
        this.debug = debug;
        this.tracingContext = tracingContext;
        /**
         * This object contains a map of all the spans sorted by their keyname.
         */
        this.spans = {};
    }
    /**
     * This methods starts the Tracing. This should be the first method called before doing anything else.
     * @param spanRootKeyname The keyname of the span at the root.
     * @param traceId The trace id if there is one.
     * @param context The context if there is one.
     */
    startTracing(spanRootKeyname = SpanKeynameEnum.RootExecution, traceId, context) {
        this.trace = new Trace(traceId, context);
        const span = new Span(spanRootKeyname, undefined, context);
        // Set the trace id into the Tracing Context. This can be used to retrieve the current trace.
        this.tracingContext.traceId = this.trace.id;
        // If the tracing is not active, simply return the created span but don't send to the tracers.
        if (this.isActive === false) {
            return span;
        }
        // Log that we are starting the tracing
        if (this.debug) {
            this.loghandler.debug("Start Tracing", {
                spanRootKeyname,
                traceId,
                context,
                trace: this.trace,
                span,
            }, TelemetryModuleKeyname);
        }
        // Call the tracers and push the trace that was just started
        this.tracers.forEach((tracer) => {
            var _a;
            (_a = tracer.traceStartedStream) === null || _a === void 0 ? void 0 : _a.push(this.trace);
        });
        // Define the rootSpan of the trace as the newly created Span. This is the root span.
        this.trace.rootSpan = span;
        // Call the addSpan method to ensure that the span will be added.
        this.addSpan(span);
        return span;
    }
    /**
     * This method starts a new span.
     * @param keyname The keyname for this new span.
     * @param parentKeyname The keyname of the parent span.
     * @param context The context if there is one.
     */
    startSpan(keyname, parentKeyname, context) {
        var _a;
        // Check if there's an active trace. If not, start one.
        if (this.trace === undefined) {
            this.startTracing(SpanKeynameEnum.RootExecution, undefined, context);
        }
        // Create the new span
        const span = new Span(keyname, context);
        if (this.trace === undefined) {
            this.loghandler.error("The trace should not be undefined at this point.");
            return span; // Return because tracing should not throw.
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        span.trace = this.trace;
        // Retrieve the parent and add it to the span.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let parentSpan = this.trace.rootSpan;
        // Check to find the parentKeyname in our internal map of spans. If n ot, the rootSpan will be the parent since every span
        // needs at least one parent.
        if (parentKeyname) {
            parentSpan = (_a = this.spans[parentKeyname]) !== null && _a !== void 0 ? _a : parentSpan;
        }
        // Add the new span as a child of its parent.
        parentSpan.addChild(span);
        this.addSpan(span);
        return span;
    }
    /**
     * This methods adds an already created Span to the trace. It assumes that it its hierarchy is correct.
     * @param span The span to add.
     */
    addSpan(span) {
        // Check if there's an active trace. If not, log an error and return;
        if (this.trace === undefined) {
            this.loghandler.error("You cannot call 'addSpan' without having an existing Trace.", { span }, TelemetryModuleKeyname);
            return span;
        }
        // Assign the tracing manager and the current trace to the span.
        span.tracingManager = this;
        if (this.trace === undefined) {
            this.loghandler.error("The trace should not be undefined at this point.");
            return span; // Return because tracing should not throw.
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        span.trace = this.trace;
        // Add it to the map of spans
        this.spans[span.keyname] = span;
        // If the tracing is deactivated, simply return the span and don't complain.
        if (this.isActive === false) {
            return span;
        }
        if (this.debug) {
            this.loghandler.debug("Adding the span", {
                keyname: span.keyname,
                trace: this.trace,
                span,
            }, TelemetryModuleKeyname);
        }
        // Notify the Tracers that a new span was started.
        this.tracers.forEach((tracer) => {
            var _a;
            (_a = tracer.spanStartedStream) === null || _a === void 0 ? void 0 : _a.push(span);
        });
        // If this span already has child spans, add them.
        span.children.forEach(childSpan => this.addSpan(childSpan));
        return span;
    }
    /**
     * This method ends the span using a keyname.
     * @param keyname The keyname of the span to end.
     */
    endSpanKeyname(keyname) {
        if (this.spans.hasOwnProperty(keyname) === false) {
            return;
        }
        this.endSpan(this.spans[keyname]);
    }
    /**
     * This methods ends the span by setting the end date and by calling the tracers.
     * It will also end the trace if the rootspan is being ended.
     * @param span The span to end.
     */
    endSpan(span) {
        var _a, _b;
        if (span.inProgress === false) {
            return;
        }
        span.inProgress = false;
        // When a span is ended, all of its children are automatically ended as well.
        span.children.forEach(childSpan => this.endSpan(childSpan));
        if (span.endDate === undefined) {
            span.endDate = Date.now();
        }
        if (this.isActive === false) {
            return;
        }
        if (this.debug) {
            this.loghandler.debug("Ending the span", {
                trace: this.trace,
                span,
            }, TelemetryModuleKeyname);
        }
        // Notify the TraceListeners that the span was ended.
        this.tracers.forEach((tracer) => {
            var _a;
            (_a = tracer.spanEndedStream) === null || _a === void 0 ? void 0 : _a.push(span);
        });
        // If the span is the root span, the trace has ended
        if (span.keyname === ((_b = (_a = this.trace) === null || _a === void 0 ? void 0 : _a.rootSpan) === null || _b === void 0 ? void 0 : _b.keyname)) {
            this.endTrace();
        }
    }
    /**
     * This method ends the trace entirely.
     */
    endTrace() {
        if (this.trace === undefined || this.trace.hasEnded) {
            return;
        }
        // End the trace by setting the end date.
        this.trace.endDate = Date.now();
        // End the trace.
        this.trace.hasEnded = true;
        // This method will recursively end all the spans
        if (this.trace.rootSpan !== undefined) {
            this.endSpan(this.trace.rootSpan);
        }
        if (this.isActive === false) {
            return;
        }
        // Notify the TraceListeners that the Trace was ended.
        this.tracers.forEach((tracer) => {
            var _a;
            (_a = tracer.traceEndedStream) === null || _a === void 0 ? void 0 : _a.push(this.trace);
        });
        // Trace time
        // Top 5 longest spans
        const longestSpans = Object.values(this.spans).sort((a, b) => b.getDuration() - a.getDuration());
        longestSpans.splice(5);
        this.loghandler.info("Ending the trace. \n" +
            "Trace duration: " + this.trace.getDuration() + " ms \n" +
            "Top 5 longest spans: \n" + longestSpans.map(span => "\t" + span.getDuration() + " ms - " + span.keyname).join("\n"), {
            trace: this.trace,
        }, TelemetryModuleKeyname);
    }
};
TracingManager = __decorate([
    moduleScoped(TelemetryModuleKeyname),
    tag("TracingManagerInterface"),
    scoped(Lifecycle.ContainerScoped),
    injectable(),
    __param(0, injectAll(ServiceDefinitionTagEnum.Tracer)),
    __param(1, inject("LogHandlerInterface")),
    __param(2, inject("%pristine.telemetry.active%")),
    __param(3, inject("%pristine.telemetry.debug%")),
    __metadata("design:paramtypes", [Array, Object, Boolean, Boolean, TracingContext])
], TracingManager);
export { TracingManager };
//# sourceMappingURL=tracing.manager.js.map