import { Trace } from "../models/trace.model";
import { Span } from "../models/span.model";
import { TracingManagerInterface } from "../interfaces/tracing-manager.interface";
import { TracingContext } from "@pristine-ts/common";
import { TracerInterface } from "../interfaces/tracer.interface";
import { LogHandlerInterface } from "@pristine-ts/logging";
/**
 * The Tracing Manager provides methods to help with tracing.
 * It is tagged and can be injected using TracingManagerInterface which facilitates mocking.
 * It is module scoped to the TelemetryModuleKeyname.
 */
export declare class TracingManager implements TracingManagerInterface {
    private readonly tracers;
    private readonly loghandler;
    private readonly isActive;
    private readonly debug;
    private readonly tracingContext;
    /**
     * This property contains a reference to the active trace.
     */
    trace?: Trace;
    /**
     * This object contains a map of all the spans sorted by their keyname.
     */
    spans: {
        [keyname: string]: Span;
    };
    /**
     * The Tracing Manager provides methods to help with tracing.
     * It is tagged and can be injected using TracingManagerInterface which facilitates mocking.
     * It is module scoped to the TelemetryModuleKeyname.
     * @param tracers The tracers to use. All services tagged with ServiceDefinitionTagEnum.Tracer will be injected here.
     * @param loghandler The log handler to output logs.
     * @param isActive Whether or not tracing is activated.
     * @param debug Whether or not tracing is in debug mode, meaning that it should output logs with the debug severity about the trace and spans.
     * This can be set to false to prevent having to much logs for every single span created.
     * @param tracingContext The tracing context.
     */
    constructor(tracers: TracerInterface[], loghandler: LogHandlerInterface, isActive: boolean, debug: boolean, tracingContext: TracingContext);
    /**
     * This methods starts the Tracing. This should be the first method called before doing anything else.
     * @param spanRootKeyname The keyname of the span at the root.
     * @param traceId The trace id if there is one.
     * @param context The context if there is one.
     */
    startTracing(spanRootKeyname?: string, traceId?: string, context?: {
        [key: string]: string;
    }): Span;
    /**
     * This method starts a new span.
     * @param keyname The keyname for this new span.
     * @param parentKeyname The keyname of the parent span.
     * @param context The context if there is one.
     */
    startSpan(keyname: string, parentKeyname?: string, context?: any): Span;
    /**
     * This methods adds an already created Span to the trace. It assumes that it its hierarchy is correct.
     * @param span The span to add.
     */
    addSpan(span: Span): Span;
    /**
     * This method ends the span using a keyname.
     * @param keyname The keyname of the span to end.
     */
    endSpanKeyname(keyname: string): void;
    /**
     * This methods ends the span by setting the end date and by calling the tracers.
     * It will also end the trace if the rootspan is being ended.
     * @param span The span to end.
     */
    endSpan(span: Span): void;
    /**
     * This method ends the trace entirely.
     */
    endTrace(): void;
}
