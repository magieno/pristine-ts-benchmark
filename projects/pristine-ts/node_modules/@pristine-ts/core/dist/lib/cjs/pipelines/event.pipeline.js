"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventPipeline = void 0;
const tsyringe_1 = require("tsyringe");
const event_1 = require("../models/event");
const common_1 = require("@pristine-ts/common");
const event_mapping_error_1 = require("../errors/event-mapping.error");
const event_pre_mapping_interception_error_1 = require("../errors/event-pre-mapping-interception.error");
const event_post_mapping_interception_error_1 = require("../errors/event-post-mapping-interception.error");
const event_dispatching_error_1 = require("../errors/event-dispatching.error");
const event_pre_response_mapping_interception_error_1 = require("../errors/event-pre-response-mapping-interception.error");
const event_post_response_mapping_interception_error_1 = require("../errors/event-post-response-mapping-interception.error");
const telemetry_1 = require("@pristine-ts/telemetry");
let EventPipeline = class EventPipeline {
    constructor(eventInterceptors, eventMappers, logHandler, tracingManager) {
        this.eventInterceptors = eventInterceptors;
        this.eventMappers = eventMappers;
        this.logHandler = logHandler;
        this.tracingManager = tracingManager;
    }
    /**
     * This method calls the interceptors that are to be executed just before the EventMappers are executed. It allows
     * for changing the raw event coming directly into the kernel.
     *
     * @param event
     * @param executionContext
     * @private
     */
    preMappingIntercept(event, executionContext) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let interceptedEvent = event;
            const span = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventPreMappingInterception);
            for (const eventInterceptor of this.eventInterceptors) {
                try {
                    interceptedEvent = (_b = yield ((_a = eventInterceptor.preMappingIntercept) === null || _a === void 0 ? void 0 : _a.call(eventInterceptor, interceptedEvent, executionContext))) !== null && _b !== void 0 ? _b : interceptedEvent;
                }
                catch (error) {
                    throw new event_pre_mapping_interception_error_1.EventPreMappingInterceptionError("There was an error while executing the PreMapping Event interceptors", error, eventInterceptor.constructor.name, event, executionContext);
                }
            }
            span.end();
            return interceptedEvent;
        });
    }
    /**
     * This method calls the interceptors that are executed just after the EventMappers have mapped the raw event into
     * an Event object.
     *
     * @param event
     * @private
     */
    postMappingIntercept(event) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let interceptedEvent = event;
            const span = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventPostMappingInterception);
            for (const eventInterceptor of this.eventInterceptors) {
                try {
                    interceptedEvent = (_b = yield ((_a = eventInterceptor.postMappingIntercept) === null || _a === void 0 ? void 0 : _a.call(eventInterceptor, interceptedEvent))) !== null && _b !== void 0 ? _b : interceptedEvent;
                }
                catch (error) {
                    throw new event_post_mapping_interception_error_1.EventPostMappingInterceptionError("There was an error while executing the PostMapping Event interceptors", error, eventInterceptor.constructor.name, event);
                }
            }
            span.end();
            return interceptedEvent;
        });
    }
    /**
     * This method calls the interceptors that are to be executed just after the EventResponse has been returned from
     * the EventDispatcher but before it is reverse mapped by the EventMappers.
     *
     * @param eventResponse
     * @private
     */
    preResponseMappingIntercept(eventResponse) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let interceptedEventResponse = eventResponse;
            const span = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventPreResponseMappingInterception);
            for (const eventInterceptor of this.eventInterceptors) {
                try {
                    interceptedEventResponse = (_b = yield ((_a = eventInterceptor.preResponseMappingIntercept) === null || _a === void 0 ? void 0 : _a.call(eventInterceptor, interceptedEventResponse))) !== null && _b !== void 0 ? _b : interceptedEventResponse;
                }
                catch (error) {
                    throw new event_pre_response_mapping_interception_error_1.EventPreResponseMappingInterceptionError("There was an error while executing the PreResponseMapping Event interceptors", error, eventInterceptor.constructor.name, eventResponse);
                }
            }
            span.end();
            return interceptedEventResponse;
        });
    }
    /**
     * This method calls the interceptors that are executed after the EventResponse object has been mapped into a simple
     * object.
     *
     * @param eventResponse The event response object to be returned from the handle method in the kernel.
     * @private
     */
    postResponseMappingIntercept(eventResponse) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let interceptedEventResponse = eventResponse;
            const span = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventPostResponseMappingInterception);
            for (const eventInterceptor of this.eventInterceptors) {
                try {
                    interceptedEventResponse = (_b = yield ((_a = eventInterceptor.postResponseMappingIntercept) === null || _a === void 0 ? void 0 : _a.call(eventInterceptor, interceptedEventResponse))) !== null && _b !== void 0 ? _b : interceptedEventResponse;
                }
                catch (error) {
                    throw new event_post_response_mapping_interception_error_1.EventPostResponseMappingInterceptionError("There was an error while executing the PostResponseMapping Event interceptors", error, eventInterceptor.constructor.name, eventResponse);
                }
            }
            span.end();
            return interceptedEventResponse;
        });
    }
    /**
     * This method executes the postMappingInterceptors and then dispatches the Event by using the EventDispatcher.
     *
     * @param event This is the event that must be dispatched.
     * @param eventDispatcher This is the eventDispatcher instance that will dispatch the Event.
     * @private
     */
    executeEvent(event, eventDispatcher) {
        return __awaiter(this, void 0, void 0, function* () {
            // 1 - Run the post mapped interceptors on every single event before they get executed.
            const interceptedEvent = yield this.postMappingIntercept(event);
            try {
                const eventExecutionSpan = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventExecution);
                // 2 - Call the EventDispatcher and retrieve the Event Response
                const response = yield eventDispatcher.dispatch(interceptedEvent);
                eventExecutionSpan.end();
                return response;
            }
            catch (error) {
                this.logHandler.error("There was an error while dispatching the event", {
                    error,
                    interceptedEvent,
                });
                throw new event_dispatching_error_1.EventDispatchingError("There was an error while dispatching the event", error, interceptedEvent);
            }
        });
    }
    /**
     *
     * @param event
     * @param executionContext
     * @param container
     */
    execute(event, executionContext, container) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventExecutions = [];
            // If the event passed is already properly typed, we simply execute it, without mapping and without calling the pre-mapping interceptors
            if (event instanceof event_1.Event) {
                eventExecutions.push({
                    events: [event],
                    executionOrder: "sequential",
                });
            }
            else {
                // 1- We have the raw event, we start by executing the PreMapping Interceptors
                const interceptedEvent = yield this.preMappingIntercept(event, executionContext);
                // 2- With the intercepted raw event, run the Events Mapping to get all the Events and the EventsExecutionOptions.
                // For each event mapper that supports the event, we batch the executions for each mapper. So it's possible to execute the same
                // event twice. This is up to the EventMappers to properly identify when they map or don't map an event. Pristine
                // isn't responsible to determine if two events are executed twice, so be careful.
                let numberOfEventMappers = 0;
                try {
                    const span = this.tracingManager.startSpan(telemetry_1.SpanKeynameEnum.EventMapping);
                    this.eventMappers.forEach(eventMapper => {
                        if (eventMapper.supportsMapping(interceptedEvent, executionContext)) {
                            eventExecutions.push(eventMapper.map(interceptedEvent, executionContext));
                            numberOfEventMappers++;
                        }
                    });
                    span.end();
                }
                catch (error) {
                    throw new event_mapping_error_1.EventMappingError("There was an error mapping the event into an Event object", event, interceptedEvent, executionContext, error);
                }
                if (numberOfEventMappers === 0) {
                    throw new event_mapping_error_1.EventMappingError("There are no Event Mappers that support the event", event, interceptedEvent, executionContext);
                }
                if (eventExecutions.length === 0 || eventExecutions.reduce((agg, eventExecution) => {
                    return agg + eventExecution.events.length;
                }, 0) === 0) {
                    throw new event_mapping_error_1.EventMappingError("There are no events to execute.", event, interceptedEvent, executionContext);
                }
            }
            const eventsExecutionPromises = [];
            // 3- Loop over the EventExecutionOptions array and start executing the events
            eventExecutions.forEach(eventExecutionOptions => {
                switch (eventExecutionOptions.executionOrder) {
                    case 'sequential':
                        eventsExecutionPromises.push(new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                            // await all events and then resolve.
                            const eventResponses = [];
                            for (const event of eventExecutionOptions.events) {
                                const childContainer = container.createChildContainer();
                                // It's important to register the CurrentChildContainer since even though it's not 100% recommended,
                                // some handlers might want to retrieve the container. For example, the RequestHandler needs this mechanism
                                // to dynamically load the controllers and not load all the containers all the time.
                                childContainer.register(common_1.ServiceDefinitionTagEnum.CurrentChildContainer, {
                                    useValue: childContainer,
                                });
                                const eventDispatcher = childContainer.resolve("EventDispatcherInterface");
                                try {
                                    eventResponses.push(yield this.executeEvent(event, eventDispatcher));
                                }
                                catch (error) {
                                    return reject(error);
                                }
                            }
                            return resolve(eventResponses);
                        })));
                        break;
                    case 'parallel':
                        for (const event of eventExecutionOptions.events) {
                            eventsExecutionPromises.push(new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                                const childContainer = container.createChildContainer();
                                // It's important to register the CurrentChildContainer since even though it's not 100% recommended,
                                // some handlers might want to retrieve the container. For example, the RequestHandler needs this mechanism
                                // to dynamically load the controllers and not load all the containers all the time.
                                childContainer.register(common_1.ServiceDefinitionTagEnum.CurrentChildContainer, {
                                    useValue: childContainer,
                                });
                                const eventDispatcher = childContainer.resolve("EventDispatcherInterface");
                                this.executeEvent(event, eventDispatcher).then(eventResponse => resolve(eventResponse)).catch(error => reject(error));
                            })));
                        }
                        break;
                }
            });
            // 4- For each event, call the PreResponseMapping Interceptors
            const eventResponses = yield Promise.all((yield Promise.all(eventsExecutionPromises)).flat().map((eventResponse) => __awaiter(this, void 0, void 0, function* () { return yield this.preResponseMappingIntercept(eventResponse); })));
            let finalResponse = {};
            // 5 - Construct the final response by calling the events mapper (reverse map method) for each eventResponse;
            // This method updates the response object that will be returned from the kernel.
            eventResponses.forEach(eventResponse => {
                this.eventMappers.forEach(eventMapper => {
                    if (eventMapper.supportsReverseMapping(eventResponse, finalResponse, executionContext)) {
                        finalResponse = eventMapper.reverseMap(eventResponse, finalResponse, executionContext);
                    }
                });
            });
            // 6 - Call the PostResponseMapping interceptors and return the final intercepted response.
            return this.postResponseMappingIntercept(finalResponse);
        });
    }
};
EventPipeline = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.injectAll)(common_1.ServiceDefinitionTagEnum.EventInterceptor)),
    __param(1, (0, tsyringe_1.injectAll)(common_1.ServiceDefinitionTagEnum.EventMapper)),
    __param(2, (0, tsyringe_1.inject)('LogHandlerInterface')),
    __param(3, (0, tsyringe_1.inject)("TracingManagerInterface")),
    __metadata("design:paramtypes", [Array, Array, Object, Object])
], EventPipeline);
exports.EventPipeline = EventPipeline;
//# sourceMappingURL=event.pipeline.js.map