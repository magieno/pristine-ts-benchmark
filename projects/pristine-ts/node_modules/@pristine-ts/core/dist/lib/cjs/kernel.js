"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kernel = void 0;
require("reflect-metadata");
const tsyringe_1 = require("tsyringe");
const common_1 = require("@pristine-ts/common");
const configuration_1 = require("@pristine-ts/configuration");
const provider_registration_error_1 = require("./errors/provider-registration.error");
const telemetry_1 = require("@pristine-ts/telemetry");
const core_module_keyname_1 = require("./core.module.keyname");
const uuid_1 = require("uuid");
const event_pipeline_1 = require("./pipelines/event.pipeline");
const kernel_initialization_error_1 = require("./errors/kernel-initialization.error");
/**
 * This is the central class that manages the lifecyle of this library.
 */
class Kernel {
    constructor() {
        /**
         * Contains a reference to the root Dependency Injection Container.
         */
        this.container = tsyringe_1.container.createChildContainer();
        /**
         * Contains a map of all the modules that were instantiated indexed by the modules names.
         * @private
         */
        this.instantiatedModules = {};
        /**
         * Contains a map of all the modules that the afterInit was run for, indexed by the modules names .
         * @private
         */
        this.afterInstantiatedModules = {};
        /**
         * Contains the unique instantiation identifier of this specific kernel instance.
         * @public
         */
        this.instantiationId = (0, uuid_1.v4)();
    }
    /**
     * This function is the entry point of the Kernel. It initializes the module for your application (AppModule) as well as its the dependencies,
     * it registers the services, registers the configurations and runs the afterInit for each module.
     * @param module
     * @param moduleConfigurationValues
     */
    start(module, moduleConfigurationValues) {
        return __awaiter(this, void 0, void 0, function* () {
            this.initializationSpan = new telemetry_1.Span(telemetry_1.SpanKeynameEnum.KernelInitialization);
            // Register the InstantiationId in the container.
            this.container.register(common_1.InternalContainerParameterEnum.KernelInstantiationId, {
                useValue: this.instantiationId,
            });
            // Inits the application module and its dependencies.
            const initializedModuleSpans = yield this.initModule(module);
            if (this.initializationSpan === undefined) {
                throw new kernel_initialization_error_1.KernelInitializationError("The InitializationSpan is undefined and shouldn't be.");
            }
            // Add every spans as a child of the Initialization Span
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            initializedModuleSpans.forEach(span => this.initializationSpan.addChild(span));
            // Register all the service tags in the container.
            yield this.registerServiceTags();
            // Register the configuration.
            const configurationInitializationSpan = new telemetry_1.Span(telemetry_1.SpanKeynameEnum.ConfigurationInitialization);
            yield this.initConfiguration(moduleConfigurationValues);
            configurationInitializationSpan.endDate = Date.now();
            this.initializationSpan.addChild(configurationInitializationSpan);
            // Run the after init of the module and its dependencies
            yield this.afterInitModule(module);
            this.initializationSpan.endDate = Date.now();
            const logHandler = this.container.resolve("LogHandlerInterface");
            logHandler.debug("The Kernel was instantiated in '" + ((this.initializationSpan.endDate - this.initializationSpan.startDate) / 1000) + "' seconds", { initializationSpan: this.initializationSpan }, core_module_keyname_1.CoreModuleKeyname);
        });
    }
    /**
     * Registers the provider registration in the container.
     * @param providerRegistration
     * @private
     */
    registerProviderRegistration(providerRegistration) {
        const args = [
            providerRegistration.token,
            providerRegistration,
        ];
        if (providerRegistration.hasOwnProperty("options")) {
            // @ts-ignore - Ignore this since even if we check for the property to exist, it complains.
            args.push(providerRegistration.options);
        }
        try {
            // @ts-ignore - Register the provider in the container
            this.container.register(...args);
        }
        catch (e) {
            throw new provider_registration_error_1.ProviderRegistrationError("There was an error registering the providerRegistration: ", providerRegistration, this);
        }
    }
    /**
     * This method receives a module and recursively calls back this method with the module dependencies
     * specified as imported by the module.
     *
     * This method also registers all the service definitions in the container.
     *
     * @param module
     * @private
     */
    initModule(module) {
        return __awaiter(this, void 0, void 0, function* () {
            // If this module is already instantiated, simply return undefined as there's no span to return;
            if (this.instantiatedModules.hasOwnProperty(module.keyname)) {
                return [];
            }
            // Add the module to the instantiatedModules map.
            this.instantiatedModules[module.keyname] = module;
            const spans = [];
            // Created the span that will be used to track how long the instantiation takes.
            const span = new telemetry_1.Span(telemetry_1.SpanKeynameEnum.ModuleInitialization + "." + module.keyname);
            const importModulesSpan = new telemetry_1.Span(telemetry_1.SpanKeynameEnum.ModuleInitializationImportModules + "." + module.keyname);
            span.addChild(importModulesSpan);
            if (module.importModules) {
                // Start by recursively importing all the packages
                for (const importedModule of module.importModules) {
                    spans.push(...(yield this.initModule(importedModule)));
                }
            }
            importModulesSpan.endDate = Date.now();
            // Add all the providers to the container
            if (module.providerRegistrations) {
                module.providerRegistrations.forEach((providerRegistration) => {
                    this.registerProviderRegistration(providerRegistration);
                });
            }
            // Run the onInit function for the module.
            if (module.onInit) {
                yield module.onInit(this.container);
            }
            // End the initialization span by setting the date. Since we don't have the tracing manager yet,
            // They will all be ended properly but they will keep the current time.
            span.endDate = Date.now();
            spans.push(span);
            return spans;
        });
    }
    /**
     * Registers all the configuration definitions that all the modules have defined.
     * @param moduleConfigurationValues
     * @private
     */
    initConfiguration(moduleConfigurationValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const configurationManager = this.container.resolve(configuration_1.ConfigurationManager);
            // Start by loading the configuration definitions of all the modules
            for (const key in this.instantiatedModules) {
                if (this.instantiatedModules.hasOwnProperty(key) === false) {
                    continue;
                }
                const instantiatedModule = this.instantiatedModules[key];
                if (instantiatedModule.configurationDefinitions) {
                    instantiatedModule.configurationDefinitions.forEach(configurationDefinition => configurationManager.register(configurationDefinition));
                }
            }
            // Load the configuration values passed by the app
            yield configurationManager.load(moduleConfigurationValues !== null && moduleConfigurationValues !== void 0 ? moduleConfigurationValues : {}, this.container);
        });
    }
    /**
     * This method receives a module and recursively calls back this method with the module dependencies
     * specified as imported by the module.
     *
     * @param module
     * @private
     */
    afterInitModule(module) {
        return __awaiter(this, void 0, void 0, function* () {
            if (module.importModules) {
                // Start by recursively importing all the packages
                for (const importedModule of module.importModules) {
                    yield this.afterInitModule(importedModule);
                }
            }
            if (this.afterInstantiatedModules.hasOwnProperty(module.keyname)) {
                // module already instantiated, we return
                return;
            }
            if (module.afterInit) {
                yield module.afterInit(this.container);
            }
            this.afterInstantiatedModules[module.keyname] = module;
        });
    }
    /**
     * This method loops through the service tag decorators defined in the taggedProviderRegistrationsRegistry and simply add
     * all the entry to the container.
     * @private
     */
    registerServiceTags() {
        common_1.taggedProviderRegistrationsRegistry.forEach((taggedRegistrationType) => {
            // Verify that if the constructor is moduleScoped, we only load it if its corresponding module is initialized.
            // If the module is not initialized, we do not load the tagged service.
            // This is to prevent that classes that are only imported get registered event if the module is not initialized.
            const moduleScopedRegistration = common_1.moduleScopedServicesRegistry[taggedRegistrationType.constructor];
            if (moduleScopedRegistration && this.instantiatedModules.hasOwnProperty(moduleScopedRegistration.moduleKeyname) === false) {
                return;
            }
            this.registerProviderRegistration(taggedRegistrationType.providerRegistration);
        });
    }
    /**
     *
     * @param event
     * @param executionContext
     */
    handle(event, executionContext) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Start the tracing
            const tracingManager = this.container.resolve("TracingManagerInterface");
            tracingManager.startTracing();
            if (this.initializationSpan) {
                (_b = (_a = tracingManager.trace) === null || _a === void 0 ? void 0 : _a.rootSpan) === null || _b === void 0 ? void 0 : _b.addChild(this.initializationSpan);
                tracingManager.addSpan(this.initializationSpan);
                // End the spans
                this.initializationSpan.end();
                // We set the initialization span to undefined since we will only add it to the Trace once
                this.initializationSpan = undefined;
            }
            // Retrieve the EventPipeline. It's the class responsible for executing all the events successfully.
            const eventPipeline = this.container.resolve(event_pipeline_1.EventPipeline);
            const response = yield eventPipeline.execute(event, executionContext, this.container);
            tracingManager.endTrace();
            return response;
        });
    }
}
exports.Kernel = Kernel;
//# sourceMappingURL=kernel.js.map