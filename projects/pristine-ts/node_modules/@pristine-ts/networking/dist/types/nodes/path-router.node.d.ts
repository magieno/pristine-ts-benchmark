import { RouterNode } from "./router.node";
import { HttpMethod } from "@pristine-ts/common";
import { Route } from "../models/route";
/**
 * This class represents a Path Node in the Router Node. It can never be a leaf node and will always have children.
 */
export declare class PathRouterNode extends RouterNode {
    readonly path: string;
    /**
     * @param path The path associated with the current node.
     * @param parent The parent node of the current node.
     */
    constructor(path: string, parent?: PathRouterNode);
    /**
     * This method adds all the required nodes to match the splitPaths and the method.
     *
     * @param splitPaths A list of all the parts of the paths spliced at the forward slashes.
     * @param method The http method for this route.
     * @param route The route.
     */
    add(splitPaths: string[], method: HttpMethod | string, route: Route, levelFromRoot: number): void;
    /**
     * This method receives an array of path and recursively calls its children if this node matches
     * the first splitPath. If the node is a MethodRouterNode, it checks to see if the method matches. If yes,
     * it returns itself as the node found. This method should always return a MethodRouterNode. However, Typescript
     * doesn't like these recursive imports so we return the base class
     *
     * @param splitPaths A list of all the parts of the paths spliced at the forward slashes.
     * @param method The http method for which to find a node.
     */
    find(splitPaths: string[], method: HttpMethod | string): RouterNode | null;
    /**
     * This httpMethod navigates the tree upwards and returns all the routeParameters
     *
     * @param splitPaths A list of all the parts of the paths spliced at the forward slashes.
     */
    getRouteParameters(splitPaths: string[]): {
        [key: string]: string;
    };
    /**
     * This method return whether or not this pathRouterNode's path is a catch-all path: "/*"
     */
    isCatchAll(): boolean;
    /**
     * This method returns whether or not this pathRouterNode represents a route parameter, e.g.: /{id} or /:id
     */
    isRouteParameter(): boolean;
    /**
     * This method returns whether the current path matches a path. We have to check if this node is a RouteParameter
     * since if it is, it will match it
     *
     * @param path
     */
    matches(path: string): boolean;
}
