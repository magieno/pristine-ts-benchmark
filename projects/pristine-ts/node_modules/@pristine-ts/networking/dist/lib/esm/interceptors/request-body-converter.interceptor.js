var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { injectable, inject } from "tsyringe";
import { moduleScoped, ServiceDefinitionTagEnum, tag } from "@pristine-ts/common";
import { NetworkingModuleKeyname } from "../networking.module.keyname";
import { InvalidBodyHttpError } from "../errors/invalid-body.http-error";
/**
 * The Request Body Converter Interceptor intercepts the request and parses the body based on the Content-tTpe header.
 * It is tagged as a RequestInterceptor so it can be automatically injected with the all the other RequestInterceptor.
 */
let RequestBodyConverterInterceptor = class RequestBodyConverterInterceptor {
    /**
     * The Request Body Converter Interceptor intercepts the request and parses the body based on the Content-Type header.
     * It is tagged as a RequestInterceptor so it can be automatically injected with the all the other RequestInterceptor.
     * @param isActive Whether or not this interceptor is active.
     * @param logHandler The log handler to output logs.
     */
    constructor(isActive, logHandler) {
        this.isActive = isActive;
        this.logHandler = logHandler;
    }
    /**
     * Intercepts the request and parses the body based on it's Content-Type header.
     * @param request The request to intercept.
     */
    interceptRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isActive === false) {
                return request;
            }
            if (request.hasHeader("Content-Type") === false) {
                return request;
            }
            const contentType = request.getHeader("Content-Type");
            switch (contentType.toLowerCase()) {
                case "application/json":
                    switch (typeof request.body) {
                        case "undefined":
                            return request;
                        case "object":
                            if (request.body.constructor === Date) {
                                const errorMessage = "This request has the Content-Type header 'application/json' but the body is a Date object which is invalid JSON.";
                                this.logHandler.error(errorMessage);
                                throw new InvalidBodyHttpError(errorMessage);
                            }
                            return request;
                        case "string":
                            try {
                                if (request.body) {
                                    request.body = JSON.parse(request.body);
                                }
                            }
                            catch (e) {
                                const errorMessage = "This request has the Content-Type header 'application/json', and the body is of type string, but the body contains invalid JSON.";
                                this.logHandler.error(errorMessage);
                                throw new InvalidBodyHttpError(errorMessage);
                            }
                            break;
                        default:
                            const errorMessage = "This request has the Content-Type header 'application/json' but the body contains invalid JSON.";
                            this.logHandler.error(errorMessage);
                            throw new InvalidBodyHttpError(errorMessage);
                    }
            }
            return request;
        });
    }
};
RequestBodyConverterInterceptor = __decorate([
    tag(ServiceDefinitionTagEnum.RequestInterceptor),
    moduleScoped(NetworkingModuleKeyname),
    injectable(),
    __param(0, inject("%" + NetworkingModuleKeyname + ".requestBodyConverter.isActive%")),
    __param(1, inject("LogHandlerInterface")),
    __metadata("design:paramtypes", [Boolean, Object])
], RequestBodyConverterInterceptor);
export { RequestBodyConverterInterceptor };
//# sourceMappingURL=request-body-converter.interceptor.js.map