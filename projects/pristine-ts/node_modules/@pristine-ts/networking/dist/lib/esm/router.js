var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { inject, singleton } from "tsyringe";
import { UrlUtil } from "./utils/url.util";
import { NotFoundHttpError } from "./errors/not-found.http-error";
import { PathRouterNode } from "./nodes/path-router.node";
import { Route } from "./models/route";
import { MethodRouterNode } from "./nodes/method-router.node";
import { ForbiddenHttpError } from "./errors/forbidden.http-error";
import { ControllerMethodParameterDecoratorResolver } from "./resolvers/controller-method-parameter-decorator.resolver";
import Url from 'url-parse';
import { tag, ServiceDefinitionTagEnum, Response } from "@pristine-ts/common";
import { NetworkingModuleKeyname } from "./networking.module.keyname";
import { SpanKeynameEnum } from "@pristine-ts/telemetry";
import { controllerRegistry } from "./decorators/controller.decorator";
import { mergeWith } from "lodash";
import { HttpError } from "./errors/http.error";
/**
 * The router service is the service that creates the routing tree from the controllers.
 * It also executes a request properly by routing it to the intended controller and returns the response.
 */
let Router = class Router {
    /**
     * The router service is the service that creates the routing tree from the controllers.
     * It also executes a request properly by routing it to the intended controller and returns the response.
     * @param loghandler The log handler
     * @param controllerMethodParameterDecoratorResolver The controller method parameter decorator resolver used to resolve the values.
     * @param authorizerManager The authorizer manager to validate authorization.
     * @param authenticationManager The authentication manager to validate authentication.
     */
    constructor(loghandler, controllerMethodParameterDecoratorResolver, authorizerManager, authenticationManager) {
        this.loghandler = loghandler;
        this.controllerMethodParameterDecoratorResolver = controllerMethodParameterDecoratorResolver;
        this.authorizerManager = authorizerManager;
        this.authenticationManager = authenticationManager;
        this.root = new PathRouterNode("/");
        // This property is used to track whether the router has been already been properly instantiated or not.
        this.setupCompleted = false;
    }
    /**
     * This method returns the whole route tree as a string.
     */
    getRouteTree() {
        let message = "";
        message = this.getRouteTreeLevel(this.root, message, 1);
        return message;
    }
    /**
     * This method takes the existing message and appends the following levels to it.
     * It calls itself recursively.
     * @param node The node to print the following levels.
     * @param message The existing message on which to append.
     * @param level The level at which we are at.
     */
    getRouteTreeLevel(node, message, level) {
        for (const child of node.children) {
            for (let i = 0; i < level; i++) {
                message += "\t";
            }
            if (child instanceof PathRouterNode) {
                message += "--" + child.path + "\n";
            }
            if (child instanceof MethodRouterNode) {
                message += "--" + child.method + "\n";
            }
            message = this.getRouteTreeLevel(child, message, level + 1);
        }
        return message;
    }
    /**
     * This method registers a Route into the Route Tree maintained by the router.
     *
     * @param path
     * @param method
     * @param route
     */
    register(path, method, route) {
        const splitPaths = UrlUtil.splitPath(path);
        this.root.add(splitPaths, method, route, 0);
    }
    // /**
    //  * This method loops through the all the classes decorated with @controller, loops through all the methods decorated
    //  * with @route and builds the dependency tree of all the routes.
    //  *
    //  * @private
    //  */
    setup() {
        if (this.setupCompleted) {
            return;
        }
        // Loop over all the controllers and control the Route Tree
        controllerRegistry.forEach(controller => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            if (controller.hasOwnProperty("__metadata__") === false) {
                return;
            }
            let basePath = (_b = (_a = controller.__metadata__) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.basePath;
            // Clean the base path by removing trailing slashes.
            if (basePath.endsWith("/")) {
                basePath = basePath.slice(0, basePath.length - 1);
            }
            for (const methodPropertyKey in (_c = controller.__metadata__) === null || _c === void 0 ? void 0 : _c.methods) {
                if (((_e = (_d = controller.__metadata__) === null || _d === void 0 ? void 0 : _d.methods) === null || _e === void 0 ? void 0 : _e.hasOwnProperty(methodPropertyKey)) === false) {
                    continue;
                }
                const method = (_f = controller.__metadata__) === null || _f === void 0 ? void 0 : _f.methods[methodPropertyKey];
                if (method.hasOwnProperty("route") === false) {
                    continue;
                }
                // Retrieve the "RouteMethodDecorator" object assigned by the @route decorator at .route
                const routeMethodDecorator = method.route;
                // Build the Route object that will be used the the router to dispatch a request to
                // the appropriate controller method
                const route = new Route(controller.constructor, routeMethodDecorator.methodKeyname);
                route.methodArguments = (_g = method.arguments) !== null && _g !== void 0 ? _g : [];
                route.context = mergeWith({}, (_j = (_h = controller.__metadata__) === null || _h === void 0 ? void 0 : _h.controller) === null || _j === void 0 ? void 0 : _j.__routeContext__, method.__routeContext__);
                // Build the proper path
                let path = routeMethodDecorator.path;
                // Clean the path by removing the first and trailing slashes.
                if (path.startsWith("/")) {
                    path = path.slice(1, path.length);
                }
                if (path.endsWith("/")) {
                    path = path.slice(0, path.length - 1);
                }
                // Build the proper path
                const routePath = basePath + "/" + path;
                // Register the route
                this.register(routePath, routeMethodDecorator.httpMethod, route);
            }
        });
        this.setupCompleted = true;
        this.loghandler.debug("Route tree: \n" + this.getRouteTree());
    }
    /**
     * This method receives a Request object, identifies the "path" its trying to hit, navigates the internally
     * maintained Route Tree, identifies the method in the controller that represents this "path", and calls the
     * method with the specified parameters.
     *
     * @param request
     * @param container
     */
    execute(request, container) {
        // todo: remove all the rejects and replace it with a response that contains an error.
        // This method cannot throw.
        const tracingManager = container.resolve("TracingManagerInterface");
        const routerRequestExecutionSpan = tracingManager.startSpan(SpanKeynameEnum.RouterRequestExecution, SpanKeynameEnum.RequestExecution);
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // Start by decomposing the URL. Set second parameter to true since we want to parse the query strings
            const url = new Url(request.url, false);
            // Split the path name
            const splitPath = UrlUtil.splitPath(url.pathname);
            const methodNodeSpan = tracingManager.startSpan(SpanKeynameEnum.RouterFindMethodRouterNode, SpanKeynameEnum.RouterRequestExecution);
            // Retrieve the node to have information about the controller
            const methodNode = this.root.find(splitPath, request.httpMethod);
            methodNodeSpan.end();
            this.loghandler.debug("Router - Execute request", {
                rootNode: this.root,
                request,
                url,
                methodNode,
            }, NetworkingModuleKeyname);
            // If node doesn't exist, throw a 404 error
            if (methodNode === null) {
                this.loghandler.error("Cannot find the path", {
                    rootNode: this.root,
                    request,
                    url,
                }, NetworkingModuleKeyname);
                routerRequestExecutionSpan.end();
                return resolve(this.executeErrorResponseInterceptors(new NotFoundHttpError("No route found for path: '" + url.pathname + "'."), request, container));
            }
            // Get the route parameters
            const routeParameters = methodNode.parent.getRouteParameters(splitPath.reverse());
            // Instantiate the controller
            const routerControllerResolverSpan = tracingManager.startSpan(SpanKeynameEnum.RouterControllerResolver, SpanKeynameEnum.RouterRequestExecution);
            const controller = container.resolve(methodNode.route.controllerInstantiationToken);
            routerControllerResolverSpan.end();
            this.loghandler.debug("Router - Before calling the authenticationManager", {
                controller,
                routeParameters
            }, NetworkingModuleKeyname);
            let identity;
            // Authenticate the request
            try {
                const routerRequestAuthenticationSpan = tracingManager.startSpan(SpanKeynameEnum.RouterRequestAuthentication, SpanKeynameEnum.RouterRequestExecution);
                identity = yield this.authenticationManager.authenticate(request, methodNode.route.context, container);
                routerRequestAuthenticationSpan.end();
                this.loghandler.debug("Router - Found identity.", {
                    identity
                }, NetworkingModuleKeyname);
            }
            catch (error) {
                this.loghandler.error("Authentication error", {
                    error,
                    request,
                    context: methodNode.route.context,
                    container
                }, NetworkingModuleKeyname);
                // Todo: check if the error is an UnauthorizedHttpError, else create one.
                if (error instanceof ForbiddenHttpError === false) {
                    error = new ForbiddenHttpError("You are not allowed to access this.");
                }
                routerRequestExecutionSpan.end();
                return resolve(this.executeErrorResponseInterceptors(error, request, container, methodNode));
            }
            // Call the controller with the resolved Method arguments
            try {
                // Verify that the identity making the request is authorized to make such a request
                if ((yield this.authorizerManager.isAuthorized(request, methodNode.route.context, container, identity)) === false) {
                    this.loghandler.error("User not authorized to access this url.", {
                        request,
                        context: methodNode.route.context,
                        container,
                        identity
                    }, NetworkingModuleKeyname);
                    routerRequestExecutionSpan.end();
                    return resolve(this.executeErrorResponseInterceptors(new ForbiddenHttpError("You are not allowed to access this."), request, container, methodNode));
                }
                // Execute all the interceptors
                const requestInterceptorsSpan = tracingManager.startSpan(SpanKeynameEnum.RequestInterceptors, SpanKeynameEnum.RouterRequestExecution);
                const interceptedRequest = yield this.executeRequestInterceptors(request, container, methodNode);
                requestInterceptorsSpan.end();
                this.loghandler.debug("Intercepted Request", {
                    request,
                    interceptedRequest,
                }, NetworkingModuleKeyname);
                // Resolve the value to inject in the method arguments that have a decorator resolver
                const resolvedMethodArguments = [];
                for (const methodArgument of methodNode.route.methodArguments) {
                    resolvedMethodArguments.push(yield this.controllerMethodParameterDecoratorResolver.resolve(methodArgument, interceptedRequest, routeParameters, identity));
                }
                this.loghandler.debug("Router - Controller argument resolved", {
                    resolvedMethodArguments,
                }, NetworkingModuleKeyname);
                const controllerResponse = controller[methodNode.route.methodPropertyKey](...resolvedMethodArguments);
                // This resolves the promise if it's a promise or promisifies the value
                // https://stackoverflow.com/a/27760489/684101
                const response = yield Promise.resolve(controllerResponse);
                this.loghandler.debug("Router - The response returned by the controller", {
                    response
                }, NetworkingModuleKeyname);
                let returnedResponse;
                // If the response is already a Response object, return the response
                if (response instanceof Response) {
                    this.loghandler.debug("Router - Response returned by the controller is a Response object", {
                        response,
                    }, NetworkingModuleKeyname);
                    returnedResponse = response;
                }
                else {
                    // If the response is not a response object, but the method hasn't thrown an error, assume the
                    // returned response is directly the body. Also assume an Http Status code of 200.
                    returnedResponse = new Response();
                    returnedResponse.status = 200;
                    returnedResponse.body = response;
                    this.loghandler.debug("Router - Response returned by the controller is NOT a Response object", {
                        response,
                        returnedResponse,
                    }, NetworkingModuleKeyname);
                }
                this.loghandler.debug("Router - The response before calling the response interceptors ", {
                    response,
                    returnedResponse,
                }, NetworkingModuleKeyname);
                const responseInterceptorsSpan = tracingManager.startSpan(SpanKeynameEnum.ResponseInterceptors, SpanKeynameEnum.RouterRequestExecution);
                const interceptedResponse = yield this.executeResponseInterceptors(returnedResponse, request, container, methodNode);
                responseInterceptorsSpan.end();
                routerRequestExecutionSpan.end();
                return resolve(interceptedResponse);
            }
            catch (error) {
                this.loghandler.error("Router - There was an error trying to execute the request in the router", {
                    error,
                }, NetworkingModuleKeyname);
                // Execute router interceptors for the error response;
                routerRequestExecutionSpan.end();
                return resolve(this.executeErrorResponseInterceptors(error, request, container, methodNode));
            }
        }));
    }
    /**
     * This method executes all the Request Interceptors and returns the request updated by the interceptors.
     *
     * @param request
     * @param container
     * @param methodNode
     * @private
     */
    executeRequestInterceptors(request, container, methodNode) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.loghandler.debug("Router - Request Interceptors - Start", {
                request,
                methodNode,
            }, NetworkingModuleKeyname);
            // Execute all the request interceptors
            let interceptedRequest = request;
            // Check first if there are any Request Interceptors
            if (container.isRegistered(ServiceDefinitionTagEnum.RequestInterceptor, true)) {
                const interceptors = container.resolveAll(ServiceDefinitionTagEnum.RequestInterceptor);
                for (const interceptor of interceptors) {
                    // We don't have a guarantee that the Router Interceptors will implement the Interface, even though we specify it should.
                    // So, we have to verify that the method exists, and if it doesn't we throw
                    if (typeof interceptor.interceptRequest === "undefined") {
                        // Simply log a message for now that the interceptors doesn't implement the 'interceptRequest' method.
                        this.loghandler.info("The Request Interceptor doesn't implement the interceptRequest method.", { name: interceptor.constructor.name, interceptor });
                        continue;
                    }
                    try {
                        // https://stackoverflow.com/a/27760489/684101
                        interceptedRequest = (_c = yield ((_b = (_a = interceptor).interceptRequest) === null || _b === void 0 ? void 0 : _b.call(_a, interceptedRequest, methodNode))) !== null && _c !== void 0 ? _c : interceptedRequest;
                    }
                    catch (e) {
                        this.loghandler.error("There was an exception thrown while executing the 'interceptedRequest' method of the RequestInterceptor named: '" + interceptor.constructor.name + "'.", { e }, NetworkingModuleKeyname);
                        throw e;
                    }
                }
            }
            this.loghandler.debug("Router - Request Interceptors - End", {
                request,
                interceptedRequest,
                methodNode,
            }, NetworkingModuleKeyname);
            return interceptedRequest;
        });
    }
    /**
     * This method executes all the Request Interceptors and returns the response updated by the interceptors.
     *
     * @param response
     * @param request
     * @param container
     * @param methodNode
     * @private
     */
    executeResponseInterceptors(response, request, container, methodNode) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.loghandler.debug("Router - Response Interceptors - Start", {
                response,
                request,
                methodNode,
            }, NetworkingModuleKeyname);
            // Execute all the request interceptors
            let interceptedResponse = response;
            // Check first if there are any Request interceptors
            if (container.isRegistered(ServiceDefinitionTagEnum.RequestInterceptor, true)) {
                const interceptors = container.resolveAll(ServiceDefinitionTagEnum.RequestInterceptor);
                for (const interceptor of interceptors) {
                    // We don't have a guarantee that the Router response interceptors will implement the Interface, even though we specify it should.
                    // So, we have to verify that the method exists, and if it doesn't we throw
                    if (typeof interceptor.interceptResponse === "undefined") {
                        // Simply log a message for now that the interceptors doesn't implement the 'interceptResponse' method.
                        this.loghandler.info("Router - The Request Interceptor doesn't implement the interceptResponse method.", { name: interceptor.constructor.name, interceptor }, NetworkingModuleKeyname);
                        continue;
                    }
                    try {
                        interceptedResponse = (_c = yield ((_b = (_a = interceptor).interceptResponse) === null || _b === void 0 ? void 0 : _b.call(_a, interceptedResponse, request, methodNode))) !== null && _c !== void 0 ? _c : interceptedResponse;
                    }
                    catch (e) {
                        this.loghandler.error("Router - There was an exception thrown while executing the 'interceptResponse' method of the RequestInterceptor named: '" + interceptor.constructor.name + "'.", { e }, NetworkingModuleKeyname);
                        throw e;
                    }
                }
            }
            this.loghandler.debug("Router - Response Interceptors - End", {
                response,
                interceptedResponse,
                request,
                methodNode,
            }, NetworkingModuleKeyname);
            return interceptedResponse;
        });
    }
    /**
     * This method executes all the Request Interceptors and returns the response updated by the error interceptors.
     *
     * @param error
     * @param request
     * @param container
     * @param methodNode
     * @private
     */
    executeErrorResponseInterceptors(error, request, container, methodNode) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.loghandler.debug("Router - Error Response Interceptors - Start", {
                error,
                request,
                methodNode,
            }, NetworkingModuleKeyname);
            // Execute all the request interceptors
            let interceptedResponse = new Response();
            if (error instanceof HttpError) {
                interceptedResponse.status = error.httpStatus;
                interceptedResponse.body = {
                    name: error.name,
                    message: error.message,
                    stack: error.stack,
                    errors: error.errors,
                    extra: error.extra,
                };
            }
            else {
                interceptedResponse.status = 500;
                interceptedResponse.body = { name: error.name, message: error.message, stack: error.stack };
            }
            interceptedResponse.request = request;
            // Check first if there are any Request interceptors
            if (container.isRegistered(ServiceDefinitionTagEnum.RequestInterceptor, true)) {
                const interceptors = container.resolveAll(ServiceDefinitionTagEnum.RequestInterceptor);
                for (const interceptor of interceptors) {
                    // We don't have a guarantee that the Router response interceptors will implement the Interface, even though we specify it should.
                    // So, we have to verify that the method exists, and if it doesn't we throw
                    if (typeof interceptor.interceptError === "undefined") {
                        // Simply log a message for now that the interceptors doesn't implement the 'interceptError' method.
                        this.loghandler.info("The Request Interceptor doesn't implement the interceptError method.", { name: interceptor.constructor.name, interceptor });
                        continue;
                    }
                    try {
                        interceptedResponse = (_c = yield ((_b = (_a = interceptor).interceptError) === null || _b === void 0 ? void 0 : _b.call(_a, error, interceptedResponse, request, methodNode))) !== null && _c !== void 0 ? _c : interceptedResponse;
                    }
                    catch (e) {
                        this.loghandler.error("There was an exception thrown while executing the 'interceptError' method of the RequestInterceptor named: '" + interceptor.constructor.name + "'.", { e }, NetworkingModuleKeyname);
                        throw e;
                    }
                }
            }
            interceptedResponse = yield this.executeResponseInterceptors(interceptedResponse, request, container, methodNode);
            this.loghandler.debug("Router - Error Response Interceptors - End", {
                error,
                interceptedResponse,
                request,
                methodNode,
            }, NetworkingModuleKeyname);
            return interceptedResponse;
        });
    }
};
Router = __decorate([
    tag("RouterInterface"),
    singleton(),
    __param(0, inject("LogHandlerInterface")),
    __param(2, inject("AuthorizerManagerInterface")),
    __param(3, inject("AuthenticationManagerInterface")),
    __metadata("design:paramtypes", [Object, ControllerMethodParameterDecoratorResolver, Object, Object])
], Router);
export { Router };
//# sourceMappingURL=router.js.map