"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseLogger = void 0;
const severity_enum_1 = require("../enums/severity.enum");
const utils_1 = require("../utils/utils");
const common_1 = require("@pristine-ts/common");
const output_mode_enum_1 = require("../enums/output-mode.enum");
/**
 * The BaseLogger is the base abstract class that all internal loggers should extend.
 * It defines the basic logic that applies to all internal loggers.
 * External loggers could extend the base logger but it is not mandatory.
 */
class BaseLogger {
    /**
     * The BaseLogger is the base abstract class that all loggers should extend.
     * It defines the basic logic that applies to all loggers.
     * @param numberOfStackedLogs The number of logs to keep in the stack and to print once a log with a high enough severity arrives.
     * @param logSeverityLevelConfiguration The number representing the severity from which logs should be outputted.
     * For example, if this is set to 3, any log that has a severity of Error(3) or critical(4) will be outputted.
     * @param logDebugDepthConfiguration The number of level to go down in an object when printing a log with the Debug severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logInfoDepthConfiguration The number of level to go down in an object when printing a log with the Info severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logWarningDepthConfiguration The number of level to go down in an object when printing a log with the Warning severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logErrorDepthConfiguration The number of level to go down in an object when printing a log with the Error severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logCriticalDepthConfiguration The number of level to go down in an object when printing a log with the Critical severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param isActivated Whether or not this particular logger is activated and should output logs.
     * @param outputMode The output mode, that the logger should use.
     * @param spaces The number of spaces to indent the outputted logs.
     */
    constructor(numberOfStackedLogs, logSeverityLevelConfiguration, logDebugDepthConfiguration, logInfoDepthConfiguration, logWarningDepthConfiguration, logErrorDepthConfiguration, logCriticalDepthConfiguration, isActivated = true, outputMode = output_mode_enum_1.OutputModeEnum.Json, spaces = 2) {
        this.numberOfStackedLogs = numberOfStackedLogs;
        this.logSeverityLevelConfiguration = logSeverityLevelConfiguration;
        this.logDebugDepthConfiguration = logDebugDepthConfiguration;
        this.logInfoDepthConfiguration = logInfoDepthConfiguration;
        this.logWarningDepthConfiguration = logWarningDepthConfiguration;
        this.logErrorDepthConfiguration = logErrorDepthConfiguration;
        this.logCriticalDepthConfiguration = logCriticalDepthConfiguration;
        this.isActivated = isActivated;
        this.outputMode = outputMode;
        this.spaces = spaces;
        /**
         * The stacked logs are the logs that were not outputted right away but that will need to be outputted if a log with a higher severity arrives.
         * @private
         */
        this.stackedLogs = {};
    }
    /**
     * Returns whether this particular logger is active and should output logs.
     */
    isActive() {
        return this.isActivated;
    }
    /**
     * Gets the formatted output log based on a log model.
     * @param log The log to be formatted.
     */
    getFormattedOutputLog(log) {
        switch (log.severity) {
            case severity_enum_1.SeverityEnum.Debug:
                return utils_1.Utils.outputLog(log, this.outputMode, this.logDebugDepthConfiguration);
            case severity_enum_1.SeverityEnum.Info:
                return utils_1.Utils.outputLog(log, this.outputMode, this.logInfoDepthConfiguration);
            case severity_enum_1.SeverityEnum.Warning:
                return utils_1.Utils.outputLog(log, this.outputMode, this.logWarningDepthConfiguration);
            case severity_enum_1.SeverityEnum.Error:
                return utils_1.Utils.outputLog(log, this.outputMode, this.logErrorDepthConfiguration);
            case severity_enum_1.SeverityEnum.Critical:
                return utils_1.Utils.outputLog(log, this.outputMode, this.logCriticalDepthConfiguration);
        }
    }
    /**
     * Captures the log and evaluates which logs need to be outputted or stacked.
     * @param log The log to be captured.
     * @protected
     */
    captureLog(log) {
        if (this.numberOfStackedLogs > 0) {
            this.setupStackedLogsArrayIfRequired(log.traceId);
            if (log.severity < this.logSeverityLevelConfiguration) {
                // We still add a log to the stack to ensure that when there's an error, we log everything.
                this.addStackedLog(log);
                return;
            }
            // We only output the stacked logs when the log severity is higher than an errore. If we show info, we don't want
            // to see a debug every time we print an info. We want that when we have an error and that the configuration
            // is set to error, we want some context and to output the previous logs.
            if (log.severity >= severity_enum_1.SeverityEnum.Error) {
                this.outputStackedLogs();
            }
        }
        if (log.severity >= this.logSeverityLevelConfiguration) {
            this.log(log);
        }
    }
    /**
     * Sets up the stack of logs if it is required.
     * @param traceId Optional trace id to stack logs based on different requests.
     * @private
     */
    setupStackedLogsArrayIfRequired(traceId) {
        var _a;
        if (this.stackedLogs.hasOwnProperty(common_1.CommonModuleKeyname) === false) {
            this.stackedLogs[common_1.CommonModuleKeyname] = [];
        }
        if (traceId && this.stackedLogs.hasOwnProperty(traceId) === false) {
            this.stackedLogs[traceId] = (_a = this.stackedLogs[common_1.CommonModuleKeyname]) !== null && _a !== void 0 ? _a : [];
        }
    }
    /**
     * Adds the log to the stacked logs and makes sure we only keep the right amount of stacked logs.
     * @param log The log to be added.
     * @private
     */
    addStackedLog(log) {
        var _a;
        const stackedLogsKey = (_a = log.traceId) !== null && _a !== void 0 ? _a : common_1.CommonModuleKeyname;
        // Push the log at the end of the array
        this.stackedLogs[stackedLogsKey].push(log);
        // If the stacked logs is already at the maximum number of logs, we delete the first log.
        if (this.stackedLogs[stackedLogsKey].length >= this.numberOfStackedLogs) {
            do {
                this.stackedLogs[stackedLogsKey].shift();
            } while (this.stackedLogs[stackedLogsKey].length > this.numberOfStackedLogs);
        }
    }
    /**
     * Outputs the stacked logs.
     * @param traceId Optional trace id so that we only output the stacked logs for this trace.
     * @private
     */
    outputStackedLogs(traceId) {
        for (const log of this.stackedLogs[common_1.CommonModuleKeyname]) {
            this.log(log);
        }
        if (traceId === undefined || this.stackedLogs.hasOwnProperty(traceId) === false) {
            return;
        }
        for (const log of this.stackedLogs[traceId]) {
            this.log(log);
        }
        this.clearStackedLogs(traceId);
    }
    /**
     * Clears the stacked logs.
     * @param traceId Optional trace id so that we only remove the stacked logs for this trace.
     * @private
     */
    clearStackedLogs(traceId) {
        this.stackedLogs[common_1.CommonModuleKeyname] = [];
        if (traceId === undefined || this.stackedLogs.hasOwnProperty(traceId) === false) {
            return;
        }
        this.stackedLogs[traceId] = [];
    }
}
exports.BaseLogger = BaseLogger;
//# sourceMappingURL=base.logger.js.map