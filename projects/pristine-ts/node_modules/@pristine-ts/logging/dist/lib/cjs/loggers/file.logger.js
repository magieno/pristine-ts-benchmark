"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileLogger = void 0;
const tsyringe_1 = require("tsyringe");
const severity_enum_1 = require("../enums/severity.enum");
const stream_1 = require("stream");
const common_1 = require("@pristine-ts/common");
const fs_1 = __importDefault(require("fs"));
const logging_module_keyname_1 = require("../logging.module.keyname");
const output_mode_enum_1 = require("../enums/output-mode.enum");
const base_logger_1 = require("./base.logger");
/**
 * The FileLogger outputs the logs into file.
 * It is registered with the tag Logger so that it can be injected along with all the other Loggers.
 * It is module scoped to the logging module so that it is only registered if the logging module is imported.
 */
let FileLogger = class FileLogger extends base_logger_1.BaseLogger {
    /**
     * The ConsoleLogger outputs the logs in the console.
     * @param numberOfStackedLogs The number of logs to keep in the stack and to print once a log with a high enough severity arrives.
     * @param logSeverityLevelConfiguration The number representing the severity from which logs should be outputted.
     * For example, if this is set to 3, any log that has a severity of Error(3) or critical(4) will be outputted.
     * @param logDebugDepthConfiguration The number of level to go down in an object when printing a log with the Debug severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logInfoDepthConfiguration The number of level to go down in an object when printing a log with the Info severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logWarningDepthConfiguration The number of level to go down in an object when printing a log with the Warning severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logErrorDepthConfiguration The number of level to go down in an object when printing a log with the Error severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param logCriticalDepthConfiguration The number of level to go down in an object when printing a log with the Critical severity.
     * We often do not need to go to the bottom layer of an object, so we can truncate at a certain depth.
     * @param isActivated Whether or not this particular logger is activated and should output logs.
     * @param outputMode The output mode, that the logger should use.
     * @param fileLoggerPretty Whether or not the file logger should prettify the output.
     * @param filePath The file path where to output the log.
     */
    constructor(numberOfStackedLogs, logSeverityLevelConfiguration, logDebugDepthConfiguration, logInfoDepthConfiguration, logWarningDepthConfiguration, logErrorDepthConfiguration, logCriticalDepthConfiguration, isActivated, outputMode, fileLoggerPretty, filePath) {
        super(numberOfStackedLogs, logSeverityLevelConfiguration, logDebugDepthConfiguration, logInfoDepthConfiguration, logWarningDepthConfiguration, logErrorDepthConfiguration, logCriticalDepthConfiguration, isActivated, outputMode, fileLoggerPretty ? 2 : 0);
        this.filePath = filePath;
        this.initialize();
    }
    /**
     * This will be called when the logger is to be terminated. It must destroy the readable stream.
     */
    terminate() {
        var _a, _b;
        (_a = this.readableStream) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.writableStream) === null || _b === void 0 ? void 0 : _b.end();
    }
    /**
     * Initializes the file logger, and opens the write stream.
     * @protected
     */
    initialize() {
        if (this.isActive()) {
            this.readableStream = new stream_1.Readable({
                objectMode: true,
                read(size) {
                    return true;
                }
            });
            this.writableStream = fs_1.default.createWriteStream(this.filePath);
            this.readableStream.on('data', chunk => {
                this.captureLog(chunk);
            });
        }
    }
    /**
     * Outputs the log in the file.
     * @param log The log to be outputted
     * @protected
     */
    log(log) {
        if (this.writableStream === undefined) {
            return;
        }
        const outputLog = this.getFormattedOutputLog(log) + ";\n";
        switch (log.severity) {
            case severity_enum_1.SeverityEnum.Debug:
                this.writableStream.write(outputLog);
                break;
            case severity_enum_1.SeverityEnum.Info:
                this.writableStream.write(outputLog);
                break;
            case severity_enum_1.SeverityEnum.Warning:
                this.writableStream.write(outputLog);
                break;
            case severity_enum_1.SeverityEnum.Error:
                this.writableStream.write(outputLog);
                break;
            case severity_enum_1.SeverityEnum.Critical:
                this.writableStream.write(outputLog);
                break;
        }
    }
};
FileLogger = __decorate([
    (0, common_1.moduleScoped)(logging_module_keyname_1.LoggingModuleKeyname),
    (0, tsyringe_1.singleton)(),
    (0, common_1.tag)(common_1.ServiceDefinitionTagEnum.Logger),
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)("%pristine.logging.numberOfStackedLogs%")),
    __param(1, (0, tsyringe_1.inject)("%pristine.logging.logSeverityLevelConfiguration%")),
    __param(2, (0, tsyringe_1.inject)("%pristine.logging.logDebugDepthConfiguration%")),
    __param(3, (0, tsyringe_1.inject)("%pristine.logging.logInfoDepthConfiguration%")),
    __param(4, (0, tsyringe_1.inject)("%pristine.logging.logWarningDepthConfiguration%")),
    __param(5, (0, tsyringe_1.inject)("%pristine.logging.logErrorDepthConfiguration%")),
    __param(6, (0, tsyringe_1.inject)("%pristine.logging.logCriticalDepthConfiguration%")),
    __param(7, (0, tsyringe_1.inject)("%pristine.logging.fileLoggerActivated%")),
    __param(8, (0, tsyringe_1.inject)("%pristine.logging.fileLoggerOutputMode%")),
    __param(9, (0, tsyringe_1.inject)("%pristine.logging.fileLoggerPretty%")),
    __param(10, (0, tsyringe_1.inject)("%pristine.logging.filePath%")),
    __metadata("design:paramtypes", [Number, Number, Number, Number, Number, Number, Number, Boolean, String, Boolean, String])
], FileLogger);
exports.FileLogger = FileLogger;
//# sourceMappingURL=file.logger.js.map