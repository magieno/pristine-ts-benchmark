"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationManager = void 0;
const tsyringe_1 = require("tsyringe");
const configuration_definition_already_exists_error_1 = require("../errors/configuration-definition-already-exists.error");
const configuration_parser_1 = require("../parsers/configuration.parser");
const configuration_validation_error_1 = require("../errors/configuration-validation.error");
let ConfigurationManager = class ConfigurationManager {
    constructor(configurationParser) {
        this.configurationParser = configurationParser;
        this.configurationDefinitions = {};
    }
    /**
     * This method registers the configuration definition that a module has defined. This method will be called for each
     * configuration definition defined in each module.
     *
     * @param configurationDefinition
     */
    register(configurationDefinition) {
        if (this.configurationDefinitions.hasOwnProperty(configurationDefinition.parameterName)) {
            throw new configuration_definition_already_exists_error_1.ConfigurationDefinitionAlreadyExistsError("There is already a configuration definition registered for this parameter name.", configurationDefinition.parameterName);
        }
        this.configurationDefinitions[configurationDefinition.parameterName] = configurationDefinition;
    }
    /**
     * This method loads the configuration values passed dynamically when instantiating the Kernel. This method
     * will verify that a corresponding configurationDefinition exists and if it does, it will resolve the value.
     *
     * This method will also check to make sure that all the expected values are being passed. For example, if a module expects
     * a configuration value to be passed, this method will throw if none are passed.
     *
     * @param moduleConfigurationValues
     * @param container
     */
    load(moduleConfigurationValues, container) {
        return __awaiter(this, void 0, void 0, function* () {
            const validationErrors = [];
            for (const key of Object.keys(moduleConfigurationValues)) {
                if (moduleConfigurationValues.hasOwnProperty(key) === false) {
                    continue;
                }
                if (this.configurationDefinitions.hasOwnProperty(key) === false) {
                    validationErrors.push("There are no ConfigurationDefinition in any of the modules for the following key: '" + key + "'.");
                    continue;
                }
                const moduleConfigurationValue = moduleConfigurationValues[key];
                const resolvedConfigurationValue = yield this.configurationParser.resolve(moduleConfigurationValue, container);
                // Register the configuration in the container
                this.registerConfigurationValue(key, resolvedConfigurationValue, container);
                // Remove the configurationDefinition for the key
                delete this.configurationDefinitions[key];
            }
            // Load all the remaining configurationDefinitions into the container. For each remaining configurationDefinition, we expect
            // the isRequired property to be false and to have a default value.
            for (const key of Object.keys(this.configurationDefinitions)) {
                if (this.configurationDefinitions.hasOwnProperty(key) === false) {
                    continue;
                }
                const configurationDefinition = this.configurationDefinitions[key];
                // Start by looping over the DefaultResolvers in case one resolvers, resolves a value, else use the default value.
                if (configurationDefinition.defaultResolvers && Array.isArray(configurationDefinition.defaultResolvers)) {
                    let isConfigurationResolvedByDefaultResolver = false;
                    for (const defaultResolver of configurationDefinition.defaultResolvers) {
                        try {
                            const resolvedConfigurationValue = yield this.configurationParser.resolve(defaultResolver, container);
                            this.registerConfigurationValue(key, resolvedConfigurationValue, container);
                            isConfigurationResolvedByDefaultResolver = true;
                            // As soon as we find a default resolver that works we stop.
                            break;
                        }
                        catch (e) {
                            // Simply ignore and continue
                        }
                    }
                    if (isConfigurationResolvedByDefaultResolver) {
                        continue;
                    }
                }
                if (configurationDefinition.isRequired === true) {
                    validationErrors.push("The Configuration with key: '" + key + "' is required and must be defined.");
                    continue;
                }
                const resolvedConfigurationValue = yield this.configurationParser.resolve(configurationDefinition.defaultValue, container);
                // Register the configuration in the container
                this.registerConfigurationValue(key, resolvedConfigurationValue, container);
            }
            if (validationErrors.length !== 0) {
                throw new configuration_validation_error_1.ConfigurationValidationError(validationErrors);
            }
            this.configurationDefinitions = {};
        });
    }
    /**
     * This method simply registers the configuration parameter with the resolved value in the container.
     *
     * @param configurationKey
     * @param value
     * @param container
     */
    registerConfigurationValue(configurationKey, value, container) {
        // Register the configuration in the container
        container.registerInstance("%" + configurationKey + "%", value);
    }
};
ConfigurationManager = __decorate([
    (0, tsyringe_1.injectable)(),
    __metadata("design:paramtypes", [configuration_parser_1.ConfigurationParser])
], ConfigurationManager);
exports.ConfigurationManager = ConfigurationManager;
//# sourceMappingURL=configuration.manager.js.map