var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Event } from "@pristine-ts/core";
import { S3EventPayload } from "../event-payloads/s3.event-payload";
import { moduleScoped, ServiceDefinitionTagEnum, tag } from "@pristine-ts/common";
import { injectable } from "tsyringe";
import { S3EventType } from "../enums/s3-event-type.enum";
import { IdentityModel } from "../models/identity.model";
import { RequestParametersModel } from "../models/request-parameters.model";
import { ResponseElementsModel } from "../models/response-elements.model";
import { S3Model } from "../models/s3.model";
import { S3BucketModel } from "../models/s3-bucket.model";
import { S3ObjectModel } from "../models/s3-object.model";
import { AwsModuleKeyname } from "../aws.module.keyname";
/**
 * Mapper to map the S3 event into a Pristine event.
 * It is tagged as an ServiceDefinitionTagEnum.EventMapper so that it can be injected with all the other event mappers.
 * It is module scoped so that it gets injected only if the AWS module is imported.
 */
let S3EventMapper = class S3EventMapper {
    /**
     * Finds the enum value corresponding to the event name.
     * @param eventName The event name of the S3 event.
     * @private
     */
    findEnum(eventName) {
        const keys = Object.keys(S3EventType).filter(key => isNaN(Number(key)));
        for (const key of keys) {
            if (S3EventType[key] === eventName) {
                return S3EventType[key];
            }
        }
        return S3EventType.UnknownS3Event;
    }
    /**
     * Parses the S3 event into a Pristine event.
     * @param rawEvent The raw S3 event
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    map(rawEvent, executionContext) {
        var _a, _b, _c, _d, _e, _f;
        const parsedEvents = [];
        for (const record of rawEvent.Records) {
            const event = new Event(this.findEnum(record.eventName), new S3EventPayload());
            event.payload.eventVersion = record.eventVersion;
            event.payload.eventSource = record.eventSource;
            event.payload.awsRegion = record.awsRegion;
            event.payload.eventTime = new Date(record.eventTime);
            event.payload.eventName = record.eventName;
            event.payload.userIdentity = new IdentityModel();
            event.payload.userIdentity.principalId = (_a = record.userIdentity) === null || _a === void 0 ? void 0 : _a.principalId;
            event.payload.requestParameters = new RequestParametersModel();
            event.payload.requestParameters.sourceIPAddress = (_b = record.requestParameters) === null || _b === void 0 ? void 0 : _b.sourceIPAddress;
            event.payload.responseElements = new ResponseElementsModel();
            if (record.responseElements) {
                event.payload.responseElements["x-amz-request-id"] = record.responseElements["x-amz-request-id"];
                event.payload.responseElements["x-amz-id-2"] = record.responseElements["x-amz-id-2"];
            }
            event.payload.s3 = new S3Model();
            event.payload.s3.s3SchemaVersion = record.s3.s3SchemaVersion;
            event.payload.s3.configurationId = record.s3.configurationId;
            event.payload.s3.bucket = new S3BucketModel();
            event.payload.s3.bucket.ownerIdentity = new IdentityModel();
            event.payload.s3.bucket.ownerIdentity.principalId = (_d = (_c = record.s3.bucket) === null || _c === void 0 ? void 0 : _c.ownerIdentity) === null || _d === void 0 ? void 0 : _d.principalId;
            event.payload.s3.bucket.name = (_e = record.s3.bucket) === null || _e === void 0 ? void 0 : _e.name;
            event.payload.s3.bucket.arn = (_f = record.s3.bucket) === null || _f === void 0 ? void 0 : _f.arn;
            event.payload.s3.object = new S3ObjectModel();
            event.payload.s3.object.key = record.s3.object.key;
            event.payload.s3.object.size = record.s3.object.size;
            event.payload.s3.object.eTag = record.s3.object.eTag;
            event.payload.s3.object.versionId = record.s3.object.versionId;
            event.payload.s3.object.sequencer = record.s3.object.sequencer;
            parsedEvents.push(event);
        }
        return {
            executionOrder: 'parallel',
            events: parsedEvents,
        };
    }
    /**
     * Determines if the parser supports the event.
     * @param event The event to verify if the parser supports.
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    supportsMapping(event, executionContext) {
        return event.hasOwnProperty("Records") &&
            Array.isArray(event.Records) &&
            event.Records[0].hasOwnProperty("eventSource") &&
            event.Records[0].eventSource === "aws:s3" &&
            event.Records[0].hasOwnProperty("s3");
    }
    /**
     * Determines if the parser supports mapping the Pristine event to an event response.
     * For now it does not support a response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    supportsReverseMapping(eventResponse, response, executionContext) {
        // todo: implement
        return false;
    }
    /**
     * Reverse maps the Pristine event into an event response.
     * For now it does not mapping a Pristine event to an S3 event response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    reverseMap(eventResponse, response, executionContext) {
        // todo: implement
    }
};
S3EventMapper = __decorate([
    moduleScoped(AwsModuleKeyname),
    tag(ServiceDefinitionTagEnum.EventMapper),
    injectable()
], S3EventMapper);
export { S3EventMapper };
//# sourceMappingURL=s3-event.mapper.js.map