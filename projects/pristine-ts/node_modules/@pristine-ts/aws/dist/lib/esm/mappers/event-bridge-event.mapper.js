var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Event } from "@pristine-ts/core";
import { moduleScoped, ServiceDefinitionTagEnum, tag } from "@pristine-ts/common";
import { injectable } from "tsyringe";
import { EventBridgePayload } from "../event-payloads/event-bridge.payload";
import { EventBridgeEventTypeEnum } from "../enums/event-bridge-event-type.enum";
import { AwsModuleKeyname } from "../aws.module.keyname";
/**
 * Mapper to map the Event bridge event into a Pristine event.
 * It is tagged as an ServiceDefinitionTagEnum.EventMapper so that it can be injected with all the other event mappers.
 * It is module scoped so that it gets injected only if the AWS module is imported.
 */
let EventBridgeEventMapper = class EventBridgeEventMapper {
    /**
     * Maps the Event bridge raw event into a Pristine event.
     * @param rawEvent The raw Event bridge event
     * @param executionContext The ExecutionContext from where the event is triggered.
     */
    map(rawEvent, executionContext) {
        const parsedEvents = [];
        let eventType;
        if (rawEvent.source === "aws.events") {
            eventType = EventBridgeEventTypeEnum.ScheduledEvent;
        }
        else {
            eventType = EventBridgeEventTypeEnum.Event;
        }
        const event = new Event(eventType, new EventBridgePayload());
        event.payload = new EventBridgePayload();
        event.payload.id = rawEvent.id;
        event.payload.source = rawEvent.source;
        event.payload.version = rawEvent.version;
        event.payload.detailType = rawEvent["detail-type"];
        event.payload.account = rawEvent.account;
        event.payload.time = rawEvent.time;
        event.payload.region = rawEvent.region;
        event.payload.resources = rawEvent.resources;
        event.payload.detail = rawEvent.detail;
        parsedEvents.push(event);
        return {
            executionOrder: 'parallel',
            events: parsedEvents,
        };
    }
    /**
     * Determines if the parser supports mapping the raw event to a Pristine event.
     * This mapper only supports raw Event Bridge events.
     * @param event The event to verify if the parser supports.
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    supportsMapping(event, executionContext) {
        return event.hasOwnProperty("source") &&
            event.hasOwnProperty("id") &&
            event.hasOwnProperty("version") &&
            event.hasOwnProperty("detail-type") &&
            event.hasOwnProperty("account") &&
            event.hasOwnProperty("time") &&
            event.hasOwnProperty("region") &&
            event.hasOwnProperty("resources") &&
            event.hasOwnProperty("detail");
    }
    /**
     * Determines if the parser supports mapping the Pristine event to an event response.
     * For now it does not support a response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    supportsReverseMapping(eventResponse, response, executionContext) {
        // todo: implement
        return false;
    }
    /**
     * Reverse maps the Pristine event into an event response.
     * For now it does not mapping a Pristine event to an Event Bridge response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    reverseMap(eventResponse, response, executionContext) {
        // todo: implement
    }
};
EventBridgeEventMapper = __decorate([
    tag(ServiceDefinitionTagEnum.EventMapper),
    moduleScoped(AwsModuleKeyname),
    injectable()
], EventBridgeEventMapper);
export { EventBridgeEventMapper };
//# sourceMappingURL=event-bridge-event.mapper.js.map