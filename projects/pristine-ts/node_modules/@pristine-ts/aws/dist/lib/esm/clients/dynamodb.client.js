var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { DynamoDB } from "@aws-sdk/client-dynamodb";
import { DataMapper, DynamoDbTable } from "@awslabs-community-fork/dynamodb-data-mapper";
import { equals, greaterThan } from "@awslabs-community-fork/dynamodb-expressions";
import { inject, injectable } from "tsyringe";
import { DynamodbItemNotFoundError } from "../errors/dynamodb-item-not-found.error";
import { DynamodbItemAlreadyExistsError } from "../errors/dynamodb-item-already-exists.error";
import { DynamodbTableNotFoundError } from "../errors/dynamodb-table-not-found.error";
import { DynamodbValidationError } from "../errors/dynamodb-validation.error";
import { DynamodbError } from "../errors/dynamodb.error";
import { tag } from "@pristine-ts/common";
import { AwsModuleKeyname } from "../aws.module.keyname";
import { ListResult } from "../results/list.result";
import { DynamodbSortOrderEnum } from "../enums/dynamodb-sort-order.enum";
/**
 * The client to use to interact with AWS DynamoDb. It is a wrapper around the client of @aws-sdk/client-dynamodb.
 * It is tagged so it can be injected using DynamodbClientInterface.
 */
let DynamodbClient = class DynamodbClient {
    /**
     * The client to use to interact with DynamoDb. It is a wrapper around the client of @aws-sdk/client-dynamodb.
     * @param logHandler The log handler used to output logs.
     * @param region The aws region for which the client will be used.
     */
    constructor(logHandler, region) {
        this.logHandler = logHandler;
        this.region = region;
    }
    /**
     * Returns the DynamoDB client from the @aws-sdk/client-dynamodb library
     */
    getClient() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return this.client = (_a = this.client) !== null && _a !== void 0 ? _a : new DynamoDB({ region: this.region });
        });
    }
    /**
     * Returns the mapper client from the @awslabs-community-fork/dynamodb-data-mapper library
     */
    getMapperClient() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return this.mapperClient = (_a = this.mapperClient) !== null && _a !== void 0 ? _a : new DataMapper({ client: yield this.getClient() });
        });
    }
    /**
     * Gets the table name from a class prototype.
     * @param classTypePrototype The class prototype containing a table name in the DynamoDbTable symbol
     * @private
     */
    getTableName(classTypePrototype) {
        return classTypePrototype[DynamoDbTable];
    }
    /**
     * Gets an object from Dynamodb. Returns null if the item was not found.
     * @param classType The class type of the object to be retrieved.
     * @param primaryKeyAndValue An object containing the primary key and the value of the object to get. (ie: {id: value})
     */
    get(classType, primaryKeyAndValue) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let item = this.createItemOfClassWithPrimaryKey(classType, primaryKeyAndValue);
                item = yield (yield this.getMapperClient()).get(item);
                this.logHandler.debug("DYNAMODB CLIENT - Got item", { item }, AwsModuleKeyname);
                return item;
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(classType.prototype), Object.keys(primaryKeyAndValue)[0]);
                if (error instanceof DynamodbItemNotFoundError) {
                    this.logHandler.warning("DYNAMODB CLIENT - Error getting", { error, classType, primaryKeyAndValue }, AwsModuleKeyname);
                    return null;
                }
                else {
                    this.logHandler.error("DYNAMODB CLIENT - Error getting", { error, classType, primaryKeyAndValue }, AwsModuleKeyname);
                }
                throw error;
            }
        });
    }
    /**
     * Lists all the objects of a type (table).
     * @param options The options to use to list.
     */
    list(options) {
        var e_1, _a;
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let scanOptions;
                if (options.pagination) {
                    scanOptions = {
                        startKey: options.pagination.startKey,
                        pageSize: options.pagination.pageSize
                    };
                }
                const iterator = (yield this.getMapperClient()).scan(options.classType, scanOptions);
                const paginator = iterator.pages();
                const items = [];
                try {
                    for (var paginator_1 = __asyncValues(paginator), paginator_1_1; paginator_1_1 = yield paginator_1.next(), !paginator_1_1.done;) {
                        const page = paginator_1_1.value;
                        items.push(...page);
                        if ((_b = options.pagination) === null || _b === void 0 ? void 0 : _b.pageSize) {
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (paginator_1_1 && !paginator_1_1.done && (_a = paginator_1.return)) yield _a.call(paginator_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this.logHandler.debug("DYNAMODB CLIENT - List items", { items }, AwsModuleKeyname);
                const paginationResult = {
                    count: paginator.count,
                    lastEvaluatedKey: paginator.lastEvaluatedKey,
                };
                return new ListResult(items, paginationResult);
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(options.classType.prototype));
                this.logHandler.error("DYNAMODB CLIENT - Error listing", { error, options, AwsModuleKeyname });
                throw error;
            }
        });
    }
    /**
     * Creates an entry in DynamoDb if this id does not already exist.
     * @param item The item to create.
     */
    create(item) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const fetchedItem = yield (yield this.getMapperClient()).get(item);
                // If we get here without throwing then we found an item.
                throw new DynamodbItemAlreadyExistsError();
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(item.constructor.prototype));
                if (error instanceof DynamodbItemNotFoundError) {
                    try {
                        item = yield (yield this.getMapperClient()).put(item);
                        this.logHandler.debug("DYNAMODB CLIENT - Created item", { item }, AwsModuleKeyname);
                        return item;
                    }
                    catch (e) {
                        e = this.convertError(e, this.getTableName(item.constructor.prototype));
                        this.logHandler.error("DYNAMODB CLIENT - Error creating", { e, item }, AwsModuleKeyname);
                        throw e;
                    }
                }
                throw error;
            }
        });
    }
    /**
     * Updates an item based on the hashkey.
     * @param item The item to update.
     */
    update(item) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                item = yield (yield this.getMapperClient()).update(item);
                this.logHandler.debug("DYNAMODB CLIENT - Updated item", { item }, AwsModuleKeyname);
                return item;
            }
            catch (error) {
                //TODO: Get the primary key.
                error = this.convertError(error, this.getTableName(item.constructor.prototype));
                this.logHandler.error("DYNAMODB CLIENT - Error updating", { error, item }, AwsModuleKeyname);
                throw error;
            }
        });
    }
    /**
     * Puts (create or replace) item.
     * @param item The item.
     */
    put(item) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                item = yield (yield this.getMapperClient()).put(item);
                this.logHandler.debug("DYNAMODB CLIENT - Put item", { item }, AwsModuleKeyname);
                return item;
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(item.constructor.prototype));
                this.logHandler.error("DYNAMODB CLIENT - Error putting", { error, item }, AwsModuleKeyname);
                throw error;
            }
        });
    }
    /**
     * Deletes an item.
     * @param classType The class type of the item to delete.
     * @param primaryKeyAndValue An object containing the primary key and the value of this key of the object to delete. (ie: {id: value})
     */
    delete(classType, primaryKeyAndValue) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const item = this.createItemOfClassWithPrimaryKey(classType, primaryKeyAndValue);
                yield (yield this.getMapperClient()).delete(item);
                this.logHandler.debug("DYNAMODB CLIENT - Deleted item", { item }, AwsModuleKeyname);
                return;
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(classType.prototype), Object.keys(primaryKeyAndValue)[0]);
                this.logHandler.error("DYNAMODB CLIENT - Error deleting", { error, classType, primaryKeyAndValue }, AwsModuleKeyname);
                throw error;
            }
        });
    }
    /**
     * Lists the item by secondary index.
     * @param options The options to use.
     */
    findBySecondaryIndex(options) {
        var e_2, _a;
        var _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const filterExpression = this.createFilterExpression(options.filterKeysAndValues, options.expiresAtFilter);
                const queryOptions = { indexName: options.secondaryIndexName, filter: filterExpression };
                if (options.pagination) {
                    queryOptions.pageSize = options.pagination.pageSize;
                    queryOptions.startKey = options.pagination.startKey;
                }
                // Makes the default scanIndexForward = false so that most recent come first.
                queryOptions.scanIndexForward = ((_b = options === null || options === void 0 ? void 0 : options.pagination) === null || _b === void 0 ? void 0 : _b.order) === DynamodbSortOrderEnum.Asc;
                this.logHandler.debug("DYNAMODB CLIENT - Querying with options", { queryOptions, options }, AwsModuleKeyname);
                const iterator = (yield this.getMapperClient()).query(options.classType, options.keyCondition, queryOptions);
                const paginator = iterator.pages();
                const items = [];
                try {
                    for (var paginator_2 = __asyncValues(paginator), paginator_2_1; paginator_2_1 = yield paginator_2.next(), !paginator_2_1.done;) {
                        const page = paginator_2_1.value;
                        items.push(...page);
                        if ((_c = options.pagination) === null || _c === void 0 ? void 0 : _c.pageSize) {
                            break;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (paginator_2_1 && !paginator_2_1.done && (_a = paginator_2.return)) yield _a.call(paginator_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                this.logHandler.debug("DYNAMODB CLIENT - Found items", { items }, AwsModuleKeyname);
                const paginationResult = {
                    count: paginator.count,
                    lastEvaluatedKey: paginator.lastEvaluatedKey,
                };
                return new ListResult(items, paginationResult);
            }
            catch (error) {
                error = this.convertError(error, this.getTableName(options.classType.prototype));
                this.logHandler.error("DYNAMODB CLIENT - Error finding by secondary index", { error, options }, AwsModuleKeyname);
                throw error;
            }
        });
    }
    /**
     * Creates the filter conditions for DynamoDb.
     * @param filterKeysAndValues A map containing the filters keys and values to apply when listing by secondary index. Every key in the map represents an AND and the values represent ORs.  (ie: {filterKey1: filterValue, filterKey2: [value1, value1]} means you need filterKey1 to equal filterValue AND filterKey2 to equal value1 OR value2)
     * @private
     */
    createFilterConditions(filterKeysAndValues) {
        const conditions = [];
        // Every key will represent an AND condition when merged with the expires at filter.
        for (const key in filterKeysAndValues) {
            if (filterKeysAndValues.hasOwnProperty(key)) {
                // Every value for one key represents an OR condition.
                if (Array.isArray(filterKeysAndValues[key])) {
                    const orExpressions = [];
                    for (const value of filterKeysAndValues[key]) {
                        orExpressions.push(Object.assign(Object.assign({}, equals(value)), { subject: key }));
                    }
                    const orExpression = {
                        type: "Or",
                        conditions: orExpressions,
                    };
                    conditions.push(orExpression);
                }
                else {
                    conditions.push(Object.assign(Object.assign({}, equals(filterKeysAndValues[key])), { subject: key }));
                }
            }
        }
        return conditions;
    }
    /**
     * Creates the final expression containing all the conditions for DyanmoDb.
     * @param filterKeysAndValues A map containing the filters keys and values to apply when listing by secondary index. Every key in the map represents an AND and the values represent ORs.  (ie: {filterKey1: filterValue, filterKey2: [value1, value1]} means you need filterKey1 to equal filterValue AND filterKey2 to equal value1 OR value2)
     * @param expiresAtFilter A filter to get only the ones that the expiration is later then the value. Can either be a Date or a number representing the timestamp in seconds. (ie: {expiresAt: new Date()}).
     * @private
     */
    createFilterExpression(filterKeysAndValues, expiresAtFilter) {
        const conditions = [];
        if (filterKeysAndValues) {
            conditions.push(...this.createFilterConditions(filterKeysAndValues));
        }
        if (expiresAtFilter) {
            conditions.push(this.createExpiresAtFilter(expiresAtFilter));
        }
        // If we only have one condition we do not create an AND expression.
        let filterExpression;
        if (conditions.length === 1) {
            filterExpression = conditions[0];
        }
        else if (conditions.length > 1) {
            filterExpression = {
                type: "And",
                conditions,
            };
        }
        return filterExpression;
    }
    /**
     * Creates the dynamodb expression for the expires at filter
     * @param expiresAtFilter A filter to get only the ones that the expiration is later then the value. Can either be a Date or a number representing the timestamp in seconds. (ie: {expiresAt: new Date()}).
     * @private
     */
    createExpiresAtFilter(expiresAtFilter) {
        let value = expiresAtFilter[Object.keys(expiresAtFilter)[0]];
        value = value instanceof Date ? Math.floor(value.getTime() / 1000) : value;
        const greaterThanExpression = Object.assign(Object.assign({}, greaterThan(value)), { subject: Object.keys(expiresAtFilter)[0] });
        return greaterThanExpression;
    }
    /**
     * Converts an error from Dynamodb into a Pristine error type.
     * @param error The error to be converted.
     * @param tableName The table name on which the error happened
     * @param primaryKey The primary key of the item for which the error happened.
     * @private
     */
    convertError(error, tableName, primaryKey) {
        this.logHandler.debug("Converting error to dynamodb error.", { error, tableName, primaryKey }, AwsModuleKeyname);
        if (error instanceof DynamodbError) {
            return error;
        }
        if (error.hasOwnProperty("name") === true) {
            switch (error.name) {
                case "ResourceNotFoundException":
                    return new DynamodbTableNotFoundError(error, tableName);
                case "ItemNotFoundException":
                    return new DynamodbItemNotFoundError(error, tableName, primaryKey);
                case "ValidationException":
                    return new DynamodbValidationError(error, tableName, primaryKey);
                default:
                    return new DynamodbError("Unknown dynamodb error: " + error.name, error, tableName, primaryKey);
            }
        }
        return new DynamodbError("Unknown dynamodb error", error, tableName, primaryKey);
    }
    /**
     * Creates an item based on the class type and the primary key and value.
     * @param classType The class type of the item.
     * @param primaryKeyAndValue An object representing the primary key and its value (ie: {id: value})
     * @private
     */
    createItemOfClassWithPrimaryKey(classType, primaryKeyAndValue) {
        const item = new classType();
        const primaryKeyName = Object.keys(primaryKeyAndValue)[0];
        // @ts-ignore - We know by the type from Dynamodb that we can access it.
        item[primaryKeyName] = primaryKeyAndValue[primaryKeyName];
        return item;
    }
};
DynamodbClient = __decorate([
    tag("DynamodbClientInterface"),
    injectable(),
    __param(0, inject("LogHandlerInterface")),
    __param(1, inject("%pristine.aws.region%")),
    __metadata("design:paramtypes", [Object, String])
], DynamodbClient);
export { DynamodbClient };
//# sourceMappingURL=dynamodb.client.js.map