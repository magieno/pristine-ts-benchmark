"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSMResolver = void 0;
const client_ssm_1 = require("@aws-sdk/client-ssm");
const ssm_resolver_error_1 = require("../errors/ssm-resolver.error");
/**
 * The resolver to resolve a parameter from AWS SSM.
 * Extends the resolver interface with the generic as a string
 */
class SSMResolver {
    /**
     * The resolver to resolve a parameter from AWS SSM
     * @param ssmParameterName The name of the SSM parameter, or the resolver to get that name.
     * @param region The AWS region in which the SSM parameter needs to be resolved from.
     * @param isSecure If the parameter is secure or not.
     */
    constructor(ssmParameterName, region, isSecure = false) {
        this.ssmParameterName = ssmParameterName;
        this.region = region;
        this.isSecure = isSecure;
    }
    /**
     * Resolves a parameter from AWS SSM.
     */
    resolve() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const ssmParameterName = yield this.resolveArgument(this.ssmParameterName);
            const region = yield this.resolveArgument(this.region);
            const ssm = new client_ssm_1.SSM({ apiVersion: 'latest', region });
            const params = {
                Name: ssmParameterName,
                WithDecryption: this.isSecure,
            };
            try {
                const parameterOutput = yield ssm.getParameter(params);
                if (!((_a = parameterOutput.Parameter) === null || _a === void 0 ? void 0 : _a.Value)) {
                    throw new ssm_resolver_error_1.SSMResolverError("No value for this parameter.", ssmParameterName);
                }
                return Promise.resolve((_b = parameterOutput.Parameter) === null || _b === void 0 ? void 0 : _b.Value);
            }
            catch (e) {
                throw new ssm_resolver_error_1.SSMResolverError("Error getting parameter from SSM.", ssmParameterName, e);
            }
        });
    }
    /**
     * Resolve the string value of an argument.
     * @param value The value to be resolved (either already a string or another resolver).
     * @private
     */
    resolveArgument(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof value === "string") {
                return value;
            }
            if (typeof value === "object" && typeof value.resolve === "function") {
                return this.resolveArgument(yield value.resolve());
            }
            throw new ssm_resolver_error_1.SSMResolverError("Cannot resolve the value passed. It isn't of type string or ResolverInterface.", {
                value,
            });
        });
    }
}
exports.SSMResolver = SSMResolver;
//# sourceMappingURL=ssm.resolver.js.map