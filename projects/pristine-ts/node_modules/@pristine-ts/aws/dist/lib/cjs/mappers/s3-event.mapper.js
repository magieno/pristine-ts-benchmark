"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3EventMapper = void 0;
const core_1 = require("@pristine-ts/core");
const s3_event_payload_1 = require("../event-payloads/s3.event-payload");
const common_1 = require("@pristine-ts/common");
const tsyringe_1 = require("tsyringe");
const s3_event_type_enum_1 = require("../enums/s3-event-type.enum");
const identity_model_1 = require("../models/identity.model");
const request_parameters_model_1 = require("../models/request-parameters.model");
const response_elements_model_1 = require("../models/response-elements.model");
const s3_model_1 = require("../models/s3.model");
const s3_bucket_model_1 = require("../models/s3-bucket.model");
const s3_object_model_1 = require("../models/s3-object.model");
const aws_module_keyname_1 = require("../aws.module.keyname");
/**
 * Mapper to map the S3 event into a Pristine event.
 * It is tagged as an ServiceDefinitionTagEnum.EventMapper so that it can be injected with all the other event mappers.
 * It is module scoped so that it gets injected only if the AWS module is imported.
 */
let S3EventMapper = class S3EventMapper {
    /**
     * Finds the enum value corresponding to the event name.
     * @param eventName The event name of the S3 event.
     * @private
     */
    findEnum(eventName) {
        const keys = Object.keys(s3_event_type_enum_1.S3EventType).filter(key => isNaN(Number(key)));
        for (const key of keys) {
            if (s3_event_type_enum_1.S3EventType[key] === eventName) {
                return s3_event_type_enum_1.S3EventType[key];
            }
        }
        return s3_event_type_enum_1.S3EventType.UnknownS3Event;
    }
    /**
     * Parses the S3 event into a Pristine event.
     * @param rawEvent The raw S3 event
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    map(rawEvent, executionContext) {
        var _a, _b, _c, _d, _e, _f;
        const parsedEvents = [];
        for (const record of rawEvent.Records) {
            const event = new core_1.Event(this.findEnum(record.eventName), new s3_event_payload_1.S3EventPayload());
            event.payload.eventVersion = record.eventVersion;
            event.payload.eventSource = record.eventSource;
            event.payload.awsRegion = record.awsRegion;
            event.payload.eventTime = new Date(record.eventTime);
            event.payload.eventName = record.eventName;
            event.payload.userIdentity = new identity_model_1.IdentityModel();
            event.payload.userIdentity.principalId = (_a = record.userIdentity) === null || _a === void 0 ? void 0 : _a.principalId;
            event.payload.requestParameters = new request_parameters_model_1.RequestParametersModel();
            event.payload.requestParameters.sourceIPAddress = (_b = record.requestParameters) === null || _b === void 0 ? void 0 : _b.sourceIPAddress;
            event.payload.responseElements = new response_elements_model_1.ResponseElementsModel();
            if (record.responseElements) {
                event.payload.responseElements["x-amz-request-id"] = record.responseElements["x-amz-request-id"];
                event.payload.responseElements["x-amz-id-2"] = record.responseElements["x-amz-id-2"];
            }
            event.payload.s3 = new s3_model_1.S3Model();
            event.payload.s3.s3SchemaVersion = record.s3.s3SchemaVersion;
            event.payload.s3.configurationId = record.s3.configurationId;
            event.payload.s3.bucket = new s3_bucket_model_1.S3BucketModel();
            event.payload.s3.bucket.ownerIdentity = new identity_model_1.IdentityModel();
            event.payload.s3.bucket.ownerIdentity.principalId = (_d = (_c = record.s3.bucket) === null || _c === void 0 ? void 0 : _c.ownerIdentity) === null || _d === void 0 ? void 0 : _d.principalId;
            event.payload.s3.bucket.name = (_e = record.s3.bucket) === null || _e === void 0 ? void 0 : _e.name;
            event.payload.s3.bucket.arn = (_f = record.s3.bucket) === null || _f === void 0 ? void 0 : _f.arn;
            event.payload.s3.object = new s3_object_model_1.S3ObjectModel();
            event.payload.s3.object.key = record.s3.object.key;
            event.payload.s3.object.size = record.s3.object.size;
            event.payload.s3.object.eTag = record.s3.object.eTag;
            event.payload.s3.object.versionId = record.s3.object.versionId;
            event.payload.s3.object.sequencer = record.s3.object.sequencer;
            parsedEvents.push(event);
        }
        return {
            executionOrder: 'parallel',
            events: parsedEvents,
        };
    }
    /**
     * Determines if the parser supports the event.
     * @param event The event to verify if the parser supports.
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    supportsMapping(event, executionContext) {
        return event.hasOwnProperty("Records") &&
            Array.isArray(event.Records) &&
            event.Records[0].hasOwnProperty("eventSource") &&
            event.Records[0].eventSource === "aws:s3" &&
            event.Records[0].hasOwnProperty("s3");
    }
    /**
     * Determines if the parser supports mapping the Pristine event to an event response.
     * For now it does not support a response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    supportsReverseMapping(eventResponse, response, executionContext) {
        // todo: implement
        return false;
    }
    /**
     * Reverse maps the Pristine event into an event response.
     * For now it does not mapping a Pristine event to an S3 event response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    reverseMap(eventResponse, response, executionContext) {
        // todo: implement
    }
};
S3EventMapper = __decorate([
    (0, common_1.moduleScoped)(aws_module_keyname_1.AwsModuleKeyname),
    (0, common_1.tag)(common_1.ServiceDefinitionTagEnum.EventMapper),
    (0, tsyringe_1.injectable)()
], S3EventMapper);
exports.S3EventMapper = S3EventMapper;
//# sourceMappingURL=s3-event.mapper.js.map