"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KafkaEventMapper = void 0;
const core_1 = require("@pristine-ts/core");
const common_1 = require("@pristine-ts/common");
const tsyringe_1 = require("tsyringe");
const kafka_event_payload_1 = require("../event-payloads/kafka.event-payload");
const kafka_event_type_enum_1 = require("../enums/kafka-event-type.enum");
const kafka_message_model_1 = require("../models/kafka-message.model");
const aws_module_keyname_1 = require("../aws.module.keyname");
/**
 * Mapper to map the Kafka event from the AWS kafka connector into a Pristine event.
 * It is tagged as an ServiceDefinitionTagEnum.EventMapper so that it can be injected with all the other event mappers.
 * It is module scoped so that it gets injected only if the AWS module is imported.
 */
let KafkaEventMapper = class KafkaEventMapper {
    /**
     * Parses the Kafka event from the AWS kafka connector into a Pristine event.
     * @param rawEvent The raw Kafka event
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    map(rawEvent, executionContext) {
        const parsedEvents = [];
        for (const key in rawEvent.records) {
            const event = new core_1.Event(kafka_event_type_enum_1.KafkaEventType.KafkaEvent, new kafka_event_payload_1.KafkaEventPayload());
            event.payload.eventSource = rawEvent.eventSource;
            event.payload.eventSourceArn = rawEvent.eventSourceArn;
            if (rawEvent.records.hasOwnProperty(key)) {
                event.payload.topicName = rawEvent.records[key][0].topic;
                for (const topicRecord of rawEvent.records[key]) {
                    const message = new kafka_message_model_1.KafkaMessageModel();
                    message.offset = topicRecord.offset;
                    message.partition = topicRecord.partition;
                    message.timestamp = new Date(topicRecord.timestamp);
                    message.timestampType = topicRecord.timestampType;
                    const decodedValue = new Buffer(topicRecord.value, 'base64').toString('ascii');
                    try {
                        message.value = JSON.parse(decodedValue);
                    }
                    catch (e) {
                        message.value = decodedValue;
                    }
                    event.payload.messages.push(message);
                }
            }
            parsedEvents.push(event);
        }
        return {
            executionOrder: 'sequential',
            events: parsedEvents,
        };
    }
    /**
     * Determines if the parser supports the event.
     * @param event The event to verify if the parser supports.
     * @param executionContext The ExecutionContext from where the event is triggered. It can easily be used to determine
     * where the current service is hosted.
     */
    supportsMapping(event, executionContext) {
        return event.hasOwnProperty("eventSource") &&
            event.eventSource === "aws:kafka";
    }
    /**
     * Determines if the parser supports mapping the Pristine event to an event response.
     * For now it does not support a response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    supportsReverseMapping(eventResponse, response, executionContext) {
        // todo: implement
        return false;
    }
    /**
     * Reverse maps the Pristine event into an event response.
     * For now it does not mapping a Pristine event to a Kafka event response.
     * @param eventResponse The event response.
     * @param response The response.
     * @param executionContext The execution context of the event.
     */
    reverseMap(eventResponse, response, executionContext) {
        // todo: implement
    }
};
KafkaEventMapper = __decorate([
    (0, common_1.tag)(common_1.ServiceDefinitionTagEnum.EventMapper),
    (0, common_1.moduleScoped)(aws_module_keyname_1.AwsModuleKeyname),
    (0, tsyringe_1.injectable)()
], KafkaEventMapper);
exports.KafkaEventMapper = KafkaEventMapper;
//# sourceMappingURL=kafka-event.mapper.js.map