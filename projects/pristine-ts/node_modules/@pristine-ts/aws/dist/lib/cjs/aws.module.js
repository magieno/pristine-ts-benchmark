"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsModule = void 0;
const dynamic_table_name_decorator_1 = require("./decorators/dynamic-table-name.decorator");
const dynamodb_data_mapper_1 = require("@awslabs-community-fork/dynamodb-data-mapper");
const logging_1 = require("@pristine-ts/logging");
const aws_module_keyname_1 = require("./aws.module.keyname");
const configuration_1 = require("@pristine-ts/configuration");
const core_1 = require("@pristine-ts/core");
__exportStar(require("./clients/clients"), exports);
__exportStar(require("./decorators/decorators"), exports);
__exportStar(require("./enums/enums"), exports);
__exportStar(require("./errors/errors"), exports);
__exportStar(require("./event-payloads/event-payloads"), exports);
__exportStar(require("./interfaces/interfaces"), exports);
__exportStar(require("./mappers/mappers"), exports);
__exportStar(require("./models/models"), exports);
__exportStar(require("./options/options"), exports);
__exportStar(require("./resolvers/resolvers"), exports);
__exportStar(require("./results/results"), exports);
__exportStar(require("./aws.module.keyname"), exports);
exports.AwsModule = {
    keyname: aws_module_keyname_1.AwsModuleKeyname,
    configurationDefinitions: [
        /**
         * The AWS region used.
         */
        {
            parameterName: aws_module_keyname_1.AwsModuleKeyname + ".region",
            isRequired: false,
            defaultValue: "us-east-1",
            defaultResolvers: [
                new configuration_1.EnvironmentVariableResolver("AWS_REGION"),
            ]
        },
    ],
    importModules: [
        logging_1.LoggingModule,
        core_1.CoreModule,
    ],
    providerRegistrations: [],
    afterInit(container) {
        return __awaiter(this, void 0, void 0, function* () {
            yield registerDynamicTableNames(container);
        });
    }
};
/**
 * This method takes all the classes that were added to the dynamicTableNameRegistry and resolves the name of the table from the dependency container and sets the DynamoDbTable to this name.
 * @param container The dependency container.
 */
const registerDynamicTableNames = (container) => __awaiter(void 0, void 0, void 0, function* () {
    for (const dynamicTableName of dynamic_table_name_decorator_1.dynamicTableNameRegistry) {
        // If the token name is not already registered in the container, we try to resolve it from the environment variables.
        if (container.isRegistered(dynamicTableName.tokenName) === false) {
            const logHandler = container.resolve("LogHandlerInterface");
            try {
                logHandler.debug("The table token name was not registered, trying to load default.", { tokenName: dynamicTableName.tokenName }, aws_module_keyname_1.AwsModuleKeyname);
                const value = yield new configuration_1.EnvironmentVariableResolver(dynamicTableName.tokenName).resolve();
                container.registerInstance(dynamicTableName.tokenName, value);
                logHandler.debug("Successfully registered table name.", { tokenName: dynamicTableName.tokenName, value }, aws_module_keyname_1.AwsModuleKeyname);
            }
            catch (e) {
                logHandler.warning("The table token name does not exist in the container.", { tokenName: dynamicTableName.tokenName }, aws_module_keyname_1.AwsModuleKeyname);
                continue;
            }
        }
        // Set the DynamoDbTable symbol with the name of the table.
        try {
            dynamicTableName.classConstructor.prototype[dynamodb_data_mapper_1.DynamoDbTable] = container.resolve(dynamicTableName.tokenName);
        }
        catch (error) {
            const logHandler = container.resolve("LogHandlerInterface");
            logHandler.error("Error resolving the dynamic table token name", { error, tokenName: dynamicTableName.tokenName }, aws_module_keyname_1.AwsModuleKeyname);
            continue;
        }
    }
});
//# sourceMappingURL=aws.module.js.map