"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marshallUpdateExpression = exports.marshallProjectionExpression = exports.marshallMathematicalExpression = exports.marshallFunctionExpression = exports.marshallConditionExpression = void 0;
const toSchemaName_1 = require("./toSchemaName");
const dynamodb_expressions_1 = require("@awslabs-community-fork/dynamodb-expressions");
/**
 * Serialize a condition expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallConditionExpression(expression, schema, attributes = new dynamodb_expressions_1.ExpressionAttributes) {
    const serialized = dynamodb_expressions_1.serializeConditionExpression(normalizeConditionExpression(expression, schema), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallConditionExpression = marshallConditionExpression;
/**
 * Serialize a function expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallFunctionExpression(expression, schema, attributes = new dynamodb_expressions_1.ExpressionAttributes) {
    const serialized = normalizeFunctionExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallFunctionExpression = marshallFunctionExpression;
/**
 * Serialize a mathematical expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallMathematicalExpression(expression, schema, attributes = new dynamodb_expressions_1.ExpressionAttributes) {
    const serialized = normalizeMathematicalExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallMathematicalExpression = marshallMathematicalExpression;
/**
 * Serialize a projection expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallProjectionExpression(expression, schema, attributes = new dynamodb_expressions_1.ExpressionAttributes) {
    const serialized = dynamodb_expressions_1.serializeProjectionExpression(expression.map(el => toSchemaName_1.toSchemaName(el, schema)), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallProjectionExpression = marshallProjectionExpression;
/**
 * Serialize an update expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallUpdateExpression(expression, schema, attributes = new dynamodb_expressions_1.ExpressionAttributes) {
    const serialized = normalizeUpdateExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallUpdateExpression = marshallUpdateExpression;
function normalizeConditionExpression(expression, schema) {
    if (dynamodb_expressions_1.FunctionExpression.isFunctionExpression(expression)) {
        return normalizeFunctionExpression(expression, schema);
    }
    switch (expression.type) {
        case 'Equals':
        case 'NotEquals':
        case 'LessThan':
        case 'LessThanOrEqualTo':
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName_1.toSchemaName(expression.subject, schema), object: normalizeIfPath(expression.object, schema) });
        case 'Function':
            switch (expression.name) {
                case 'attribute_exists':
                case 'attribute_not_exists':
                    return Object.assign(Object.assign({}, expression), { subject: toSchemaName_1.toSchemaName(expression.subject, schema) });
                case 'attribute_type':
                case 'begins_with':
                case 'contains':
                    return Object.assign(Object.assign({}, expression), { subject: toSchemaName_1.toSchemaName(expression.subject, schema) });
            }
        case 'Between':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName_1.toSchemaName(expression.subject, schema), lowerBound: normalizeIfPath(expression.lowerBound, schema), upperBound: normalizeIfPath(expression.upperBound, schema) });
        case 'Membership':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName_1.toSchemaName(expression.subject, schema), values: expression.values.map(arg => normalizeIfPath(arg, schema)) });
        case 'Not':
            return Object.assign(Object.assign({}, expression), { condition: normalizeConditionExpression(expression.condition, schema) });
        case 'And':
        case 'Or':
            return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map(condition => normalizeConditionExpression(condition, schema)) });
    }
}
function normalizeFunctionExpression(expression, schema) {
    return new dynamodb_expressions_1.FunctionExpression(expression.name, ...expression.args.map(arg => normalizeIfPath(arg, schema)));
}
function normalizeMathematicalExpression(expression, schema) {
    return new dynamodb_expressions_1.MathematicalExpression(dynamodb_expressions_1.AttributePath.isAttributePath(expression.lhs) || typeof expression.lhs === 'string'
        ? toSchemaName_1.toSchemaName(expression.lhs, schema)
        : expression.lhs, expression.operator, dynamodb_expressions_1.AttributePath.isAttributePath(expression.rhs) || typeof expression.rhs === 'string'
        ? toSchemaName_1.toSchemaName(expression.rhs, schema)
        : expression.rhs);
}
const mapsToTransform = [
    ['toAdd', 'add'],
    ['toDelete', 'delete'],
    ['toSet', 'set'],
];
function normalizeUpdateExpression(expression, schema) {
    const normalized = new dynamodb_expressions_1.UpdateExpression;
    for (const [dataSet, exprMethod] of mapsToTransform) {
        for (const [path, value] of expression[dataSet]) {
            normalized[exprMethod](toSchemaName_1.toSchemaName(path, schema), value);
        }
    }
    expression.toRemove.forEach(el => normalized.remove(toSchemaName_1.toSchemaName(el, schema)));
    return normalized;
}
function normalizeIfPath(path, schema) {
    if (dynamodb_expressions_1.AttributePath.isAttributePath(path)) {
        return toSchemaName_1.toSchemaName(path, schema);
    }
    return path;
}
//# sourceMappingURL=marshallExpression.js.map