import { toSchemaName } from './toSchemaName';
import { AttributePath, FunctionExpression, MathematicalExpression, UpdateExpression, ExpressionAttributes, serializeConditionExpression, serializeProjectionExpression, } from '@awslabs-community-fork/dynamodb-expressions';
/**
 * Serialize a condition expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
export function marshallConditionExpression(expression, schema, attributes = new ExpressionAttributes) {
    const serialized = serializeConditionExpression(normalizeConditionExpression(expression, schema), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
/**
 * Serialize a function expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
export function marshallFunctionExpression(expression, schema, attributes = new ExpressionAttributes) {
    const serialized = normalizeFunctionExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
/**
 * Serialize a mathematical expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
export function marshallMathematicalExpression(expression, schema, attributes = new ExpressionAttributes) {
    const serialized = normalizeMathematicalExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
/**
 * Serialize a projection expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
export function marshallProjectionExpression(expression, schema, attributes = new ExpressionAttributes) {
    const serialized = serializeProjectionExpression(expression.map(el => toSchemaName(el, schema)), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
/**
 * Serialize an update expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
export function marshallUpdateExpression(expression, schema, attributes = new ExpressionAttributes) {
    const serialized = normalizeUpdateExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
function normalizeConditionExpression(expression, schema) {
    if (FunctionExpression.isFunctionExpression(expression)) {
        return normalizeFunctionExpression(expression, schema);
    }
    switch (expression.type) {
        case 'Equals':
        case 'NotEquals':
        case 'LessThan':
        case 'LessThanOrEqualTo':
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName(expression.subject, schema), object: normalizeIfPath(expression.object, schema) });
        case 'Function':
            switch (expression.name) {
                case 'attribute_exists':
                case 'attribute_not_exists':
                    return Object.assign(Object.assign({}, expression), { subject: toSchemaName(expression.subject, schema) });
                case 'attribute_type':
                case 'begins_with':
                case 'contains':
                    return Object.assign(Object.assign({}, expression), { subject: toSchemaName(expression.subject, schema) });
            }
        case 'Between':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName(expression.subject, schema), lowerBound: normalizeIfPath(expression.lowerBound, schema), upperBound: normalizeIfPath(expression.upperBound, schema) });
        case 'Membership':
            return Object.assign(Object.assign({}, expression), { subject: toSchemaName(expression.subject, schema), values: expression.values.map(arg => normalizeIfPath(arg, schema)) });
        case 'Not':
            return Object.assign(Object.assign({}, expression), { condition: normalizeConditionExpression(expression.condition, schema) });
        case 'And':
        case 'Or':
            return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map(condition => normalizeConditionExpression(condition, schema)) });
    }
}
function normalizeFunctionExpression(expression, schema) {
    return new FunctionExpression(expression.name, ...expression.args.map(arg => normalizeIfPath(arg, schema)));
}
function normalizeMathematicalExpression(expression, schema) {
    return new MathematicalExpression(AttributePath.isAttributePath(expression.lhs) || typeof expression.lhs === 'string'
        ? toSchemaName(expression.lhs, schema)
        : expression.lhs, expression.operator, AttributePath.isAttributePath(expression.rhs) || typeof expression.rhs === 'string'
        ? toSchemaName(expression.rhs, schema)
        : expression.rhs);
}
const mapsToTransform = [
    ['toAdd', 'add'],
    ['toDelete', 'delete'],
    ['toSet', 'set'],
];
function normalizeUpdateExpression(expression, schema) {
    const normalized = new UpdateExpression;
    for (const [dataSet, exprMethod] of mapsToTransform) {
        for (const [path, value] of expression[dataSet]) {
            normalized[exprMethod](toSchemaName(path, schema), value);
        }
    }
    expression.toRemove.forEach(el => normalized.remove(toSchemaName(el, schema)));
    return normalized;
}
function normalizeIfPath(path, schema) {
    if (AttributePath.isAttributePath(path)) {
        return toSchemaName(path, schema);
    }
    return path;
}
//# sourceMappingURL=marshallExpression.js.map