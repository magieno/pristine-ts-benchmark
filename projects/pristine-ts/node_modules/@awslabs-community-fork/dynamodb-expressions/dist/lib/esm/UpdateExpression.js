import { AttributePath } from "./AttributePath";
import { FunctionExpression } from "./FunctionExpression";
import { MathematicalExpression } from "./MathematicalExpression";
/**
 * An object representing a DynamoDB update expression.
 */
export class UpdateExpression {
    constructor() {
        this.toAdd = new Map();
        this.toDelete = new Map();
        this.toRemove = new Set();
        this.toSet = new Map();
    }
    /**
     * Add a directive to the expression's `add` clause.
     */
    add(path, value) {
        this.toAdd.set(AttributePath.isAttributePath(path) ? path : new AttributePath(path), value);
    }
    /**
     * Add a directive to the expression's `delete` clause.
     */
    delete(path, value) {
        this.toDelete.set(AttributePath.isAttributePath(path) ? path : new AttributePath(path), value);
    }
    /**
     * Add a directive to the expression's `remove` clause.
     */
    remove(path) {
        this.toRemove.add(AttributePath.isAttributePath(path) ? path : new AttributePath(path));
    }
    /**
     * Add a directive to the expression's `set` clause.
     */
    set(path, value) {
        this.toSet.set(AttributePath.isAttributePath(path) ? path : new AttributePath(path), value);
    }
    serialize(attributes) {
        const clauses = [];
        const phrases = [];
        for (const [mapping, verb] of [
            [this.toAdd, 'ADD'],
            [this.toDelete, 'DELETE'],
        ]) {
            for (const [key, value] of mapping.entries()) {
                phrases.push(`${attributes.addName(key)} ${attributes.addValue(value)}`);
            }
            if (phrases.length > 0) {
                clauses.push(`${verb} ${phrases.join(', ')}`);
                phrases.length = 0;
            }
        }
        for (const [key, value] of this.toSet.entries()) {
            phrases.push(`${attributes.addName(key)} = ${FunctionExpression.isFunctionExpression(value) || MathematicalExpression.isMathematicalExpression(value)
                ? value.serialize(attributes) : attributes.addValue(value)}`);
        }
        if (phrases.length > 0) {
            clauses.push(`SET ${phrases.join(', ')}`);
            phrases.length = 0;
        }
        for (const keyToRemove of this.toRemove) {
            phrases.push(attributes.addName(keyToRemove));
        }
        if (phrases.length > 0) {
            clauses.push(`REMOVE ${phrases.join(', ')}`);
            phrases.length = 0;
        }
        return clauses.join(' ');
    }
}
//# sourceMappingURL=UpdateExpression.js.map