import { AttributePath } from "./AttributePath";
import { FunctionExpression } from "./FunctionExpression";
/**
 * Create an expression predicate asserting that the subject is equal to the
 * predicate.
 */
export function equals(operand) {
    return {
        type: 'Equals',
        object: operand,
    };
}
export function notEquals(operand) {
    return {
        type: 'NotEquals',
        object: operand,
    };
}
export function lessThan(operand) {
    return {
        type: 'LessThan',
        object: operand,
    };
}
export function lessThanOrEqualTo(operand) {
    return {
        type: 'LessThanOrEqualTo',
        object: operand,
    };
}
export function greaterThan(operand) {
    return {
        type: 'GreaterThan',
        object: operand,
    };
}
export function greaterThanOrEqualTo(operand) {
    return {
        type: 'GreaterThanOrEqualTo',
        object: operand,
    };
}
export function between(lowerBound, upperBound) {
    return {
        type: 'Between',
        lowerBound,
        upperBound,
    };
}
export function inList(...operands) {
    return {
        type: 'Membership',
        values: operands,
    };
}
export function attributeExists() {
    return {
        type: 'Function',
        name: 'attribute_exists',
    };
}
export function attributeNotExists() {
    return {
        type: 'Function',
        name: 'attribute_not_exists',
    };
}
export function attributeType(expected) {
    return {
        type: 'Function',
        name: 'attribute_type',
        expected,
    };
}
export function beginsWith(expected) {
    return {
        type: 'Function',
        name: 'begins_with',
        expected,
    };
}
export function contains(expected) {
    return {
        type: 'Function',
        name: 'contains',
        expected,
    };
}
/**
 * Evaluate whether the provided value is a condition expression predicate.
 */
export function isConditionExpressionPredicate(arg) {
    if (arg && typeof arg === 'object') {
        switch (arg.type) {
            case 'Equals':
            case 'NotEquals':
            case 'LessThan':
            case 'LessThanOrEqualTo':
            case 'GreaterThan':
            case 'GreaterThanOrEqualTo':
                return arg.object !== undefined;
            case 'Between':
                return arg.lowerBound !== undefined
                    && arg.upperBound !== undefined;
            case 'Membership':
                return Array.isArray(arg.values);
            case 'Function':
                switch (arg.name) {
                    case 'attribute_exists':
                    case 'attribute_not_exists':
                        return true;
                    case 'attribute_type':
                    case 'begins_with':
                    case 'contains':
                        return typeof arg.expected === 'string';
                }
        }
    }
    return false;
}
export function isConditionExpressionSubject(arg) {
    return Boolean(arg)
        && typeof arg === 'object'
        && (typeof arg.subject === 'string' || AttributePath.isAttributePath(arg.subject));
}
/**
 * Evaluates whether the provided value is a condition expression.
 */
export function isConditionExpression(arg) {
    if (FunctionExpression.isFunctionExpression(arg)) {
        return true;
    }
    if (Boolean(arg) && typeof arg === 'object') {
        switch (arg.type) {
            case 'Not':
                return isConditionExpression(arg.condition);
            case 'And':
            case 'Or':
                if (Array.isArray(arg.conditions)) {
                    for (const condition of arg.conditions) {
                        if (!isConditionExpression(condition)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            default:
                return isConditionExpressionSubject(arg)
                    && isConditionExpressionPredicate(arg);
        }
    }
    return false;
}
/**
 * Convert the provided condition expression object to a string, escaping any
 * values and attributes to expression-safe placeholders whose expansion value
 * will be managed by the provided ExpressionAttributes object.
 */
export function serializeConditionExpression(condition, attributes) {
    if (FunctionExpression.isFunctionExpression(condition)) {
        return condition.serialize(attributes);
    }
    switch (condition.type) {
        case 'Equals':
            return serializeBinaryComparison(condition, attributes, '=');
        case 'NotEquals':
            return serializeBinaryComparison(condition, attributes, '<>');
        case 'LessThan':
            return serializeBinaryComparison(condition, attributes, '<');
        case 'LessThanOrEqualTo':
            return serializeBinaryComparison(condition, attributes, '<=');
        case 'GreaterThan':
            return serializeBinaryComparison(condition, attributes, '>');
        case 'GreaterThanOrEqualTo':
            return serializeBinaryComparison(condition, attributes, '>=');
        case 'Between':
            return `${attributes.addName(condition.subject)} BETWEEN ${serializeOperand(condition.lowerBound, attributes)} AND ${serializeOperand(condition.upperBound, attributes)}`;
        case 'Membership':
            return `${attributes.addName(condition.subject)} IN (${condition.values.map(val => serializeOperand(val, attributes))
                .join(', ')})`;
        case 'Function':
            const subject = AttributePath.isAttributePath(condition.subject)
                ? condition.subject
                : new AttributePath(condition.subject);
            switch (condition.name) {
                case 'attribute_exists':
                case 'attribute_not_exists':
                    return (new FunctionExpression(condition.name, subject))
                        .serialize(attributes);
                case 'attribute_type':
                case 'begins_with':
                case 'contains':
                    return (new FunctionExpression(condition.name, subject, condition.expected))
                        .serialize(attributes);
            }
        case 'Not':
            return `NOT (${serializeConditionExpression(condition.condition, attributes)})`;
        case 'And':
        case 'Or':
            if (condition.conditions.length === 1) {
                return serializeConditionExpression(condition.conditions[0], attributes);
            }
            return condition.conditions
                .map(cond => `(${serializeConditionExpression(cond, attributes)})`)
                .join(` ${condition.type.toUpperCase()} `);
    }
}
function serializeBinaryComparison(cond, attributes, comparator) {
    return `${attributes.addName(cond.subject)} ${comparator} ${serializeOperand(cond.object, attributes)}`;
}
function serializeOperand(operand, attributes) {
    if (FunctionExpression.isFunctionExpression(operand)) {
        return operand.serialize(attributes);
    }
    return AttributePath.isAttributePath(operand)
        ? attributes.addName(operand)
        : attributes.addValue(operand);
}
//# sourceMappingURL=ConditionExpression.js.map