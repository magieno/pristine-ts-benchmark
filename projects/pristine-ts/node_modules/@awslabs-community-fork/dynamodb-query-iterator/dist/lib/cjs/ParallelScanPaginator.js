"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParallelScanPaginator = void 0;
const mergeConsumedCapacities_1 = require("./mergeConsumedCapacities");
const ScanPaginator_1 = require("./ScanPaginator");
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
class ParallelScanPaginator {
    constructor(client, input, scanState = nullScanState(input.TotalSegments)) {
        this.pending = [];
        this.lastResolved = Promise.resolve();
        const { TotalSegments } = input;
        if (scanState.length !== TotalSegments) {
            throw new Error(`Parallel scan state must have a length equal to the number of `
                + `scan segments. Expected an array of ${TotalSegments} but`
                + `received an array with ${scanState.length} elements.`);
        }
        this.iterators = new Array(TotalSegments);
        for (let i = 0; i < TotalSegments; i++) {
            const iterator = new ScanPaginator_1.ScanPaginator(client, Object.assign(Object.assign({}, input), { Segment: i, ExclusiveStartKey: scanState[i].LastEvaluatedKey }));
            this.iterators[i] = iterator;
            // If the segment has not been initialized or a pagination token has
            // been received, request the next page.
            if (!scanState[i].initialized || scanState[i].LastEvaluatedKey) {
                this.refillPending(iterator, i);
            }
        }
        this._scanState = [...scanState];
    }
    /**
     * @inheritDoc
     */
    [Symbol.asyncIterator]() {
        return this;
    }
    /**
     * @inheritDoc
     */
    get consumedCapacity() {
        return this.iterators.reduce((merged, paginator) => mergeConsumedCapacities_1.mergeConsumedCapacities(merged, paginator.consumedCapacity), undefined);
    }
    /**
     * @inheritDoc
     */
    get count() {
        return this.iterators.reduce((sum, paginator) => sum + paginator.count, 0);
    }
    /**
     * @inheritDoc
     */
    next() {
        this.lastResolved = this.lastResolved.then(() => this.getNext());
        return this.lastResolved;
    }
    getNext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pending.length === 0) {
                return doneSigil();
            }
            // Grab the next available result from any segment.
            const { iterator, result: { value, done }, segment, } = yield Promise.race(this.pending.map(pending => pending.result));
            // Update the scan state for this segment. This will either be the last
            // evaluated key (for an unfinished segment) or undefined (for a
            // completed segment).
            this._scanState[segment] = {
                initialized: true,
                LastEvaluatedKey: value && value.LastEvaluatedKey,
            };
            // Remove the result from the pending set.
            for (let i = this.pending.length - 1; i >= 0; i--) {
                if (this.pending[i].iterator === iterator) {
                    this.pending.splice(i, 1);
                }
            }
            // If the iterator is not finished, add its next result to the pending
            // set.
            if (!done) {
                this.refillPending(iterator, segment);
                return { value, done };
            }
            else {
                // If a segment has finished but there are still outstanding
                // requests, recur. A done sigil will be returned when the pending
                // queue is empty.
                return this.getNext();
            }
        });
    }
    /**
     * @inheritDoc
     */
    return() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pending.length = 0;
            return Promise.all(this.iterators.map(iterator => iterator.return()))
                .then(doneSigil);
        });
    }
    /**
     * @inheritDoc
     */
    get scannedCount() {
        return this.iterators.reduce((sum, paginator) => sum + paginator.scannedCount, 0);
    }
    /**
     * A snapshot of the current state of a parallel scan. May be used to resume
     * a parallel scan with a separate paginator.
     */
    get scanState() {
        return [...this._scanState];
    }
    refillPending(iterator, segment) {
        // Use .push to reorder segments within the array of pending results.
        // Promise.race will iterate over the array of pending results until a
        // resolved promise is found and therefore will naturally favor promises
        // towards the head of the queue. Removing resolved segments and sending
        // them to the back of the line will keep this implementation detail
        // from creating hot and cold scan segments.
        this.pending.push({
            iterator: iterator,
            result: iterator.next()
                .then(result => ({ iterator, result, segment })),
        });
    }
}
exports.ParallelScanPaginator = ParallelScanPaginator;
function doneSigil() {
    return { done: true };
}
/**
 * `Array.prototype.fill` is not available in IE, so a loop is used instead
 */
function nullScanState(length) {
    const target = new Array(length);
    for (let i = 0; i < length; i++) {
        target[i] = { initialized: false };
    }
    return target;
}
//# sourceMappingURL=ParallelScanPaginator.js.map