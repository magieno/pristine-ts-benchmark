"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Marshaller = exports.InvalidHandlingStrategies = exports.EmptyHandlingStrategies = void 0;
const BinarySet_1 = require("./BinarySet");
const isArrayBuffer_1 = require("./isArrayBuffer");
const NumberValue_1 = require("./NumberValue");
const NumberValueSet_1 = require("./NumberValueSet");
exports.EmptyHandlingStrategies = {
    omit: 'omit',
    nullify: 'nullify',
    leave: 'leave',
};
exports.InvalidHandlingStrategies = {
    /**
     * Remove any invalid values from the serialized output.
     */
    omit: 'omit',
    /**
     * Throw an error when an unserializable value is encountered.
     */
    throw: 'throw',
};
/**
 * A class that will convert arbitrary JavaScript data types to their most
 * logical in the DynamoDB schema.
 */
class Marshaller {
    constructor({ onEmpty = 'leave', onInvalid = 'throw', unwrapNumbers = false } = {}) {
        this.onEmpty = onEmpty;
        this.onInvalid = onInvalid;
        this.unwrapNumbers = unwrapNumbers;
    }
    /**
     * Convert a JavaScript object with string keys and arbitrary values into an
     * object with string keys and DynamoDB AttributeValue objects as values.
     */
    marshallItem(item) {
        const value = this.marshallValue(item);
        if (!(value && value.M) && this.onInvalid === 'throw') {
            throw new Error(`Cannot serialize ${typeof item} as an attribute map`);
        }
        return value && value.M ? value.M : {};
    }
    /**
     * Convert a JavaScript value into a DynamoDB AttributeValue or `undefined`.
     *
     * @throws Error if the value cannot be converted to a DynamoDB type and the
     * marshaller has been configured to throw on invalid input.
     */
    marshallValue(value) {
        switch (typeof value) {
            case 'boolean':
                return { BOOL: value };
            case 'number':
                return { N: value.toString(10) };
            case 'object':
                return this.marshallComplexType(value);
            case 'string':
                return value ? { S: value } : this.handleEmptyString(value);
            case 'undefined':
                return undefined;
            case 'function':
            case 'symbol':
            default:
                if (this.onInvalid === 'throw') {
                    throw new Error(`Cannot serialize values of the ${typeof value} type`);
                }
        }
    }
    /**
     * Convert a DynamoDB operation result (an object with string keys and
     * AttributeValue values) to an object with string keys and native
     * JavaScript values.
     */
    unmarshallItem(item) {
        return this.unmarshallValue({ M: item });
    }
    /**
     * Convert a DynamoDB AttributeValue into a native JavaScript value.
     */
    unmarshallValue(item) {
        if (item.S !== undefined) {
            return item.S;
        }
        if (item.N !== undefined) {
            return this.unwrapNumbers
                ? Number(item.N)
                : new NumberValue_1.NumberValue(item.N);
        }
        if (item.B !== undefined) {
            return item.B;
        }
        if (item.BOOL !== undefined) {
            return item.BOOL;
        }
        if (item.NULL !== undefined) {
            return null;
        }
        if (item.SS !== undefined) {
            const set = new Set();
            for (let member of item.SS) {
                set.add(member);
            }
            return set;
        }
        if (item.NS !== undefined) {
            if (this.unwrapNumbers) {
                const set = new Set();
                for (let member of item.NS) {
                    set.add(Number(member));
                }
                return set;
            }
            return new NumberValueSet_1.NumberValueSet(item.NS.map(numberString => new NumberValue_1.NumberValue(numberString)));
        }
        if (item.BS !== undefined) {
            return new BinarySet_1.BinarySet(item.BS);
        }
        if (item.L !== undefined) {
            return item.L.map(this.unmarshallValue.bind(this));
        }
        const { M = {} } = item;
        return Object.keys(M).reduce((map, key) => {
            map[key] = this.unmarshallValue(M[key]);
            return map;
        }, {});
    }
    marshallComplexType(value) {
        if (value === null) {
            return { NULL: true };
        }
        if (NumberValue_1.NumberValue.isNumberValue(value)) {
            return { N: value.toString() };
        }
        if (isBinaryValue(value)) {
            return this.marshallBinaryValue(value);
        }
        if (isSet(value)) {
            return this.marshallSet(value);
        }
        if (isMap(value)) {
            return this.marshallMap(value);
        }
        if (isIterable(value)) {
            return this.marshallList(value);
        }
        return this.marshallObject(value);
    }
    marshallBinaryValue(binary) {
        if (binary.byteLength > 0 || this.onEmpty === 'leave') {
            return { B: binary };
        }
        if (this.onEmpty === 'nullify') {
            return { NULL: true };
        }
    }
    marshallList(list) {
        const values = [];
        for (let value of list) {
            const marshalled = this.marshallValue(value);
            if (marshalled) {
                values.push(marshalled);
            }
        }
        return { L: values };
    }
    marshallMap(map) {
        const members = {};
        for (let [key, value] of map) {
            if (typeof key !== 'string') {
                if (this.onInvalid === 'omit') {
                    continue;
                }
                throw new Error(`MapAttributeValues must have strings as keys; ${typeof key} received instead`);
            }
            const marshalled = this.marshallValue(value);
            if (marshalled) {
                members[key] = marshalled;
            }
        }
        return { M: members };
    }
    marshallObject(object) {
        return {
            M: Object.keys(object).reduce((map, key) => {
                const marshalled = this.marshallValue(object[key]);
                if (marshalled) {
                    map[key] = marshalled;
                }
                return map;
            }, {}),
        };
    }
    marshallSet(arg) {
        switch (getSetType(arg[Symbol.iterator]().next().value)) {
            case 'binary':
                return this.collectSet(arg, isBinaryEmpty, 'BS', 'binary');
            case 'number':
                return this.collectSet(arg, isNumberEmpty, 'NS', 'number', stringifyNumber);
            case 'string':
                return this.collectSet(arg, isStringEmpty, 'SS', 'string');
            case 'unknown':
                if (this.onInvalid === 'throw') {
                    throw new Error('Sets must be composed of strings,' +
                        ' binary values, or numbers');
                }
                return undefined;
            case 'undefined':
                if (this.onEmpty === 'nullify') {
                    return { NULL: true };
                }
        }
    }
    collectSet(set, isEmpty, tag, elementType, transform) {
        const values = [];
        for (let element of set) {
            if (getSetType(element) !== elementType) {
                if (this.onInvalid === 'omit') {
                    continue;
                }
                throw new Error(`Unable to serialize ${typeof element} as a member of a ${elementType} set`);
            }
            if (!isEmpty(element) ||
                this.onEmpty === 'leave') {
                values.push(transform ? transform(element) : element);
            }
        }
        if (values.length > 0 || this.onEmpty === 'leave') {
            // I get the idea but there's an issue here where it's possible we are missing some required fields.
            // @ts-ignore
            return { [tag]: values };
        }
        if (this.onEmpty === 'nullify') {
            return { NULL: true };
        }
    }
    handleEmptyString(value) {
        switch (this.onEmpty) {
            case 'leave':
                return { S: value };
            case 'nullify':
                return { NULL: true };
        }
    }
}
exports.Marshaller = Marshaller;
function getSetType(arg) {
    const type = typeof arg;
    if (type === 'string' || type === 'number' || type === 'undefined') {
        return type;
    }
    if (NumberValue_1.NumberValue.isNumberValue(arg)) {
        return 'number';
    }
    if (ArrayBuffer.isView(arg) || isArrayBuffer_1.isArrayBuffer(arg)) {
        return 'binary';
    }
    return 'unknown';
}
function isBinaryEmpty(arg) {
    return arg.byteLength === 0;
}
function isBinaryValue(arg) {
    return ArrayBuffer.isView(arg) || isArrayBuffer_1.isArrayBuffer(arg);
}
function isIterable(arg) {
    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
}
function isMap(arg) {
    return Boolean(arg)
        && Object.prototype.toString.call(arg) === '[object Map]';
}
function isNumberEmpty() {
    return false;
}
function isSet(arg) {
    return Boolean(arg)
        && Object.prototype.toString.call(arg) === '[object Set]';
}
function isStringEmpty(arg) {
    return arg.length === 0;
}
function stringifyNumber(arg) {
    return arg.toString();
}
//# sourceMappingURL=Marshaller.js.map