var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { VERSION, } from './constants';
import { ItemNotFoundException } from './ItemNotFoundException';
import { ParallelScanIterator } from './ParallelScanIterator';
import { DynamoDbTable, getSchema, getTableName } from './protocols';
import { QueryIterator } from './QueryIterator';
import { ScanIterator } from './ScanIterator';
import { BatchGet, BatchWrite, } from '@awslabs-community-fork/dynamodb-batch-iterator';
import { getSchemaName, isKey, keysFromSchema, marshallConditionExpression, marshallItem, marshallKey, marshallUpdateExpression, marshallValue, toSchemaName, unmarshallItem, } from '@awslabs-community-fork/dynamodb-data-marshaller';
import { AttributePath, AttributeValue as AttributeValueClass, ExpressionAttributes, FunctionExpression, MathematicalExpression, serializeProjectionExpression, UpdateExpression, } from '@awslabs-community-fork/dynamodb-expressions';
import { waitForTableExists, waitForTableNotExists, } from '@aws-sdk/client-dynamodb';
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
/**
 * Object mapper for domain object interaction with DynamoDB.
 *
 * To use, define a schema that describes how an item is represented in a
 * DynamoDB table. This schema will be used to marshall a native JavaScript
 * object into its desired persisted form. Attributes present on the object
 * but not in the schema will be ignored.
 */
export class DataMapper {
    constructor({ client, readConsistency = 'eventual', skipVersionCheck = false, tableNamePrefix = '' }) {
        client.config.customUserAgent = [[` dynamodb-data-mapper-js/${VERSION}`]];
        this.client = client;
        this.readConsistency = readConsistency;
        this.skipVersionCheck = skipVersionCheck;
        this.tableNamePrefix = tableNamePrefix;
    }
    /**
     * Deletes items from DynamoDB in batches of 25 or fewer via one or more
     * BatchWriteItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any delete requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to delete.
     */
    batchDelete(items) {
        return __asyncGenerator(this, arguments, function* batchDelete_1() {
            var e_1, _a;
            const iter = this.batchWrite(function mapToDelete() {
                return __asyncGenerator(this, arguments, function* mapToDelete_1() {
                    var e_2, _a;
                    try {
                        for (var items_1 = __asyncValues(items), items_1_1; items_1_1 = yield __await(items_1.next()), !items_1_1.done;) {
                            const item = items_1_1.value;
                            yield yield __await(['delete', item]);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) yield __await(_a.call(items_1));
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                });
            }());
            try {
                for (var iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), !iter_1_1.done;) {
                    const written = iter_1_1.value;
                    yield yield __await(written[1]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iter_1_1 && !iter_1_1.done && (_a = iter_1.return)) yield __await(_a.call(iter_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
     * BatchGetItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any get requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to get.
     */
    batchGet(items, { readConsistency = this.readConsistency, perTableOptions = {} } = {}) {
        return __asyncGenerator(this, arguments, function* batchGet_1() {
            var e_3, _a;
            const state = {};
            const options = {};
            const batch = new BatchGet(this.client, this.mapGetBatch(items, state, perTableOptions, options), {
                ConsistentRead: readConsistency === 'strong' ? true : undefined,
                PerTableOptions: options
            });
            try {
                for (var batch_1 = __asyncValues(batch), batch_1_1; batch_1_1 = yield __await(batch_1.next()), !batch_1_1.done;) {
                    const [tableName, marshalled] = batch_1_1.value;
                    const { keyProperties, itemSchemata } = state[tableName];
                    const { constructor, schema, } = itemSchemata[itemIdentifier(marshalled, keyProperties)];
                    yield yield __await(unmarshallItem(schema, marshalled, constructor));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (batch_1_1 && !batch_1_1.done && (_a = batch_1.return)) yield __await(_a.call(batch_1));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Puts items into DynamoDB in batches of 25 or fewer via one or more
     * BatchWriteItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any put requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to put.
     */
    batchPut(items) {
        return __asyncGenerator(this, arguments, function* batchPut_1() {
            var e_4, _a;
            const generator = isIterable(items)
                ? function* mapToPut() {
                    for (const item of items) {
                        yield ['put', item];
                    }
                }()
                : function mapToPut() {
                    return __asyncGenerator(this, arguments, function* mapToPut_1() {
                        var e_5, _a;
                        try {
                            for (var items_2 = __asyncValues(items), items_2_1; items_2_1 = yield __await(items_2.next()), !items_2_1.done;) {
                                const item = items_2_1.value;
                                yield yield __await(['put', item]);
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) yield __await(_a.call(items_2));
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    });
                }();
            try {
                for (var _b = __asyncValues(this.batchWrite(generator)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const written = _c.value;
                    yield yield __await(written[1]);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or
     * more BatchWriteItem operations. The items may belong to any number of
     * tables; tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any write requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of tuples of the
     * string 'put'|'delete' and the item on which to perform the specified
     * write action.
     */
    batchWrite(items) {
        return __asyncGenerator(this, arguments, function* batchWrite_1() {
            var e_6, _a;
            const state = {};
            const batch = new BatchWrite(this.client, this.mapWriteBatch(items, state));
            try {
                for (var batch_2 = __asyncValues(batch), batch_2_1; batch_2_1 = yield __await(batch_2.next()), !batch_2_1.done;) {
                    const [tableName, { DeleteRequest, PutRequest }] = batch_2_1.value;
                    const { keyProperties, itemSchemata } = state[tableName];
                    const attributes = PutRequest
                        ? PutRequest.Item
                        : (DeleteRequest || { Key: {} }).Key;
                    if (attributes === undefined) {
                        continue;
                    }
                    const { constructor, schema, } = itemSchemata[itemIdentifier(attributes, keyProperties)];
                    yield yield __await([
                        PutRequest ? 'put' : 'delete',
                        unmarshallItem(schema, attributes, constructor)
                    ]);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (batch_2_1 && !batch_2_1.done && (_a = batch_2.return)) yield __await(_a.call(batch_2));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Perform a CreateTable operation using the schema accessible via the
     * {DynamoDbSchema} property and the table name accessible via the
     * {DynamoDbTable} property on the prototype of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use.
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the CreateTable operation
     */
    createTable(valueConstructor, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = getSchema(valueConstructor.prototype);
            const { attributes, indexKeys, tableKeys } = keysFromSchema(schema);
            const TableName = this.getTableName(valueConstructor.prototype);
            let throughput = {};
            if (options.billingMode !== 'PAY_PER_REQUEST') {
                throughput = Object.assign({}, provisionedThroughput(options.readCapacityUnits, options.writeCapacityUnits));
            }
            const { streamViewType = 'NONE', indexOptions = {}, billingMode, sseSpecification, } = options;
            const { TableDescription: { TableStatus } = { TableStatus: 'CREATING' } } = yield this.client.createTable(Object.assign(Object.assign(Object.assign(Object.assign({}, indexDefinitions(indexKeys, indexOptions, schema)), { TableName }), throughput), { BillingMode: billingMode, AttributeDefinitions: attributeDefinitionList(attributes), KeySchema: keyTypesToElementList(tableKeys), StreamSpecification: streamViewType === 'NONE'
                    ? { StreamEnabled: false }
                    : { StreamEnabled: true, StreamViewType: streamViewType }, SSESpecification: sseSpecification
                    ? {
                        Enabled: true,
                        SSEType: sseSpecification.sseType,
                        KMSMasterKeyId: sseSpecification.kmsMasterKeyId,
                    }
                    : { Enabled: false } }));
            if (TableStatus !== 'ACTIVE') {
                yield waitForTableExists({
                    client: this.client,
                    maxWaitTime: 20 * 25, // seems to be the old default value
                }, { TableName });
            }
        });
    }
    /**
     * Perform a UpdateTable operation using the schema accessible via the
     * {DynamoDbSchema} property, the table name accessible via the
     * {DynamoDbTable} property on the prototype of the constructor supplied,
     * and the specified global secondary index name.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use.
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the UpdateTable operation
     */
    createGlobalSecondaryIndex(valueConstructor, indexName, { indexOptions = {}, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = getSchema(valueConstructor.prototype);
            const { attributes, indexKeys } = keysFromSchema(schema);
            const TableName = this.getTableName(valueConstructor.prototype);
            const globalSecondaryIndexes = indexDefinitions(indexKeys, indexOptions, schema).GlobalSecondaryIndexes;
            const indexSearch = globalSecondaryIndexes === undefined ? [] : globalSecondaryIndexes.filter(function (index) {
                return index.IndexName === indexName;
            });
            const indexDefinition = indexSearch[0];
            const { TableDescription: { TableStatus } = { TableStatus: 'UPDATING' } } = yield this.client.updateTable({
                GlobalSecondaryIndexUpdates: [{
                        Create: Object.assign({}, indexDefinition)
                    }],
                TableName,
                AttributeDefinitions: attributeDefinitionList(attributes),
            });
            if (TableStatus !== 'ACTIVE') {
                yield waitForTableExists({
                    client: this.client,
                    maxWaitTime: 20 * 25, // seems to be the old default value
                }, { TableName });
            }
        });
    }
    /**
     * If the index does not already exist, perform a UpdateTable operation
     * using the schema accessible via the {DynamoDbSchema} property, the
     * table name accessible via the {DynamoDbTable} property on the prototype
     * of the constructor supplied, and the index name.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use. Note that the index will not be usable for queries
     * until it has finished backfilling
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the UpdateTable operation
     */
    ensureGlobalSecondaryIndexExists(valueConstructor, indexName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const TableName = this.getTableName(valueConstructor.prototype);
            try {
                const { Table: { GlobalSecondaryIndexes } = { GlobalSecondaryIndexes: [] } } = yield this.client.describeTable({ TableName });
                const indexSearch = GlobalSecondaryIndexes === undefined ? [] : GlobalSecondaryIndexes.filter(function (index) {
                    return index.IndexName === indexName;
                });
                if (indexSearch.length === 0) {
                    yield this.createGlobalSecondaryIndex(valueConstructor, indexName, options);
                }
            }
            catch (err) {
                throw err;
            }
        });
    }
    delete(itemOrParameters, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let item;
            if ('item' in itemOrParameters &&
                itemOrParameters.item[DynamoDbTable]) {
                item = itemOrParameters.item;
                options = itemOrParameters;
            }
            else {
                item = itemOrParameters;
            }
            let { condition, returnValues = 'ALL_OLD', skipVersionCheck = this.skipVersionCheck, } = options;
            const schema = getSchema(item);
            const req = {
                TableName: this.getTableName(item),
                Key: marshallKey(schema, item),
                ReturnValues: returnValues,
            };
            if (!skipVersionCheck) {
                for (const prop of Object.keys(schema)) {
                    let inputMember = item[prop];
                    const fieldSchema = schema[prop];
                    if (isVersionAttribute(fieldSchema) && inputMember !== undefined) {
                        const { condition: versionCondition } = handleVersionAttribute(prop, inputMember);
                        condition = condition
                            ? { type: 'And', conditions: [condition, versionCondition] }
                            : versionCondition;
                    }
                }
            }
            if (condition) {
                const attributes = new ExpressionAttributes();
                req.ConditionExpression = marshallConditionExpression(condition, schema, attributes).expression;
                if (Object.keys(attributes.names).length > 0) {
                    req.ExpressionAttributeNames = attributes.names;
                }
                if (Object.keys(attributes.values).length > 0) {
                    req.ExpressionAttributeValues = attributes.values;
                }
            }
            const { Attributes } = yield this.client.deleteItem(req);
            if (Attributes) {
                return unmarshallItem(schema, Attributes, item.constructor);
            }
        });
    }
    /**
     * Perform a DeleteTable operation using the schema accessible via the
     * {DynamoDbSchema} property and the table name accessible via the
     * {DynamoDbTable} property on the prototype of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * deleted and can no longer be used.
     *
     * @param valueConstructor  The constructor used for values in the table.
     */
    deleteTable(valueConstructor) {
        return __awaiter(this, void 0, void 0, function* () {
            const TableName = this.getTableName(valueConstructor.prototype);
            yield this.client.deleteTable({ TableName });
            yield waitForTableNotExists({
                client: this.client,
                maxWaitTime: 20 * 25, // seems to be the old default value
            }, { TableName });
        });
    }
    /**
     * If the table does not already exist, perform a CreateTable operation
     * using the schema accessible via the {DynamoDbSchema} property and the
     * table name accessible via the {DynamoDbTable} property on the prototype
     * of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use.
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the CreateTable operation
     */
    ensureTableExists(valueConstructor, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const TableName = this.getTableName(valueConstructor.prototype);
            try {
                const { Table: { TableStatus } = { TableStatus: 'CREATING' } } = yield this.client.describeTable({ TableName });
                if (TableStatus !== 'ACTIVE') {
                    yield waitForTableExists({
                        client: this.client,
                        maxWaitTime: 20 * 25, // seems to be the old default value
                    }, { TableName });
                }
            }
            catch (err) {
                if (err.name === 'ResourceNotFoundException') {
                    yield this.createTable(valueConstructor, options);
                }
                else {
                    throw err;
                }
            }
        });
    }
    /**
     * If the table exists, perform a DeleteTable operation using the schema
     * accessible via the {DynamoDbSchema} property and the table name
     * accessible via the {DynamoDbTable} property on the prototype of the
     * constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * deleted and can no longer be used.
     *
     * @param valueConstructor  The constructor used for values in the table.
     */
    ensureTableNotExists(valueConstructor) {
        return __awaiter(this, void 0, void 0, function* () {
            const TableName = this.getTableName(valueConstructor.prototype);
            try {
                const { Table: { TableStatus: status } = { TableStatus: 'CREATING' } } = yield this.client.describeTable({ TableName });
                if (status === 'DELETING') {
                    yield waitForTableNotExists({
                        client: this.client,
                        maxWaitTime: 20 * 25, // seems to be the old default value
                    }, { TableName });
                    return;
                }
                else if (status === 'CREATING' || status === 'UPDATING') {
                    yield waitForTableExists({
                        client: this.client,
                        maxWaitTime: 20 * 25, // seems to be the old default value
                    }, { TableName });
                }
                yield this.deleteTable(valueConstructor);
            }
            catch (err) {
                if (err.name !== 'ResourceNotFoundException') {
                    throw err;
                }
            }
        });
    }
    get(itemOrParameters, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let item;
            if ('item' in itemOrParameters &&
                itemOrParameters.item[DynamoDbTable]) {
                item = itemOrParameters.item;
                options = itemOrParameters;
            }
            else {
                item = itemOrParameters;
            }
            const { projection, readConsistency = this.readConsistency } = options;
            const schema = getSchema(item);
            const req = {
                TableName: this.getTableName(item),
                Key: marshallKey(schema, item)
            };
            if (readConsistency === 'strong') {
                req.ConsistentRead = true;
            }
            if (projection) {
                const attributes = new ExpressionAttributes();
                req.ProjectionExpression = serializeProjectionExpression(projection.map(propName => toSchemaName(propName, schema)), attributes);
                if (Object.keys(attributes.names).length > 0) {
                    req.ExpressionAttributeNames = attributes.names;
                }
            }
            const { Item } = yield this.client.getItem(req);
            if (Item) {
                return unmarshallItem(schema, Item, item.constructor);
            }
            throw new ItemNotFoundException(req);
        });
    }
    parallelScan(ctorOrParams, segments, options = {}) {
        let valueConstructor;
        if (typeof segments !== 'number') {
            valueConstructor = ctorOrParams.valueConstructor;
            segments = ctorOrParams.segments;
            options = ctorOrParams;
        }
        else {
            valueConstructor = ctorOrParams;
        }
        return new ParallelScanIterator(this.client, valueConstructor, segments, Object.assign(Object.assign({ readConsistency: this.readConsistency }, options), { tableNamePrefix: this.tableNamePrefix }));
    }
    put(itemOrParameters, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let item;
            if ('item' in itemOrParameters &&
                itemOrParameters.item[DynamoDbTable]) {
                item = itemOrParameters.item;
                options = itemOrParameters;
            }
            else {
                item = itemOrParameters;
            }
            let { condition, skipVersionCheck = this.skipVersionCheck, } = options;
            const schema = getSchema(item);
            const req = {
                TableName: this.getTableName(item),
                Item: marshallItem(schema, item),
            };
            if (!skipVersionCheck) {
                for (const key of Object.keys(schema)) {
                    let inputMember = item[key];
                    const fieldSchema = schema[key];
                    const { attributeName = key } = fieldSchema;
                    if (isVersionAttribute(fieldSchema)) {
                        const { condition: versionCond } = handleVersionAttribute(key, inputMember);
                        if (req.Item === undefined) {
                            continue;
                        }
                        if (req.Item[attributeName]) {
                            req.Item[attributeName].N = (Number(req.Item[attributeName].N) + 1).toString();
                        }
                        else {
                            req.Item[attributeName] = { N: "0" };
                        }
                        condition = condition
                            ? { type: 'And', conditions: [condition, versionCond] }
                            : versionCond;
                    }
                }
            }
            if (condition) {
                const attributes = new ExpressionAttributes();
                req.ConditionExpression = marshallConditionExpression(condition, schema, attributes).expression;
                if (Object.keys(attributes.names).length > 0) {
                    req.ExpressionAttributeNames = attributes.names;
                }
                if (Object.keys(attributes.values).length > 0) {
                    req.ExpressionAttributeValues = attributes.values;
                }
            }
            yield this.client.putItem(req);
            return unmarshallItem(schema, req.Item, item.constructor);
        });
    }
    query(valueConstructorOrParameters, keyCondition, options = {}) {
        let valueConstructor;
        if (!keyCondition) {
            valueConstructor = valueConstructorOrParameters.valueConstructor;
            keyCondition = valueConstructorOrParameters.keyCondition;
            options = valueConstructorOrParameters;
        }
        else {
            valueConstructor = valueConstructorOrParameters;
        }
        return new QueryIterator(this.client, valueConstructor, keyCondition, Object.assign(Object.assign({ readConsistency: this.readConsistency }, options), { tableNamePrefix: this.tableNamePrefix }));
    }
    scan(ctorOrParams, options = {}) {
        let valueConstructor;
        if ('valueConstructor' in ctorOrParams &&
            ctorOrParams.valueConstructor.prototype &&
            ctorOrParams.valueConstructor.prototype[DynamoDbTable]) {
            valueConstructor = ctorOrParams.valueConstructor;
            options = ctorOrParams;
        }
        else {
            valueConstructor = ctorOrParams;
        }
        return new ScanIterator(this.client, valueConstructor, Object.assign(Object.assign({ readConsistency: this.readConsistency }, options), { tableNamePrefix: this.tableNamePrefix }));
    }
    update(itemOrParameters, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let item;
            if ('item' in itemOrParameters &&
                itemOrParameters.item[DynamoDbTable]) {
                item = itemOrParameters.item;
                options = itemOrParameters;
            }
            else {
                item = itemOrParameters;
            }
            let { condition, onMissing = 'remove', skipVersionCheck = this.skipVersionCheck, } = options;
            const schema = getSchema(item);
            const expr = new UpdateExpression();
            const itemKey = {};
            for (const key of Object.keys(schema)) {
                let inputMember = item[key];
                const fieldSchema = schema[key];
                if (isKey(fieldSchema)) {
                    itemKey[key] = inputMember;
                }
                else if (isVersionAttribute(fieldSchema)) {
                    const { condition: versionCond, value } = handleVersionAttribute(key, inputMember);
                    expr.set(key, value);
                    if (!skipVersionCheck) {
                        condition = condition
                            ? { type: 'And', conditions: [condition, versionCond] }
                            : versionCond;
                    }
                }
                else if (inputMember === undefined) {
                    if (onMissing === 'remove') {
                        expr.remove(key);
                    }
                }
                else {
                    const marshalled = marshallValue(fieldSchema, inputMember);
                    if (marshalled) {
                        expr.set(key, new AttributeValueClass(marshalled));
                    }
                }
            }
            return this.doExecuteUpdateExpression(expr, itemKey, getSchema(item), getTableName(item), item.constructor, { condition });
        });
    }
    /**
     * Execute a custom update expression using the schema and table name
     * defined on the provided `valueConstructor`.
     *
     * This method does not support automatic version checking, as the current
     * state of a table's version attribute cannot be inferred from an update
     * expression object. To perform a version check manually, add a condition
     * expression:
     *
     * ```typescript
     *  const currentVersion = 1;
     *  updateExpression.set('nameOfVersionAttribute', currentVersion + 1);
     *  const condition = {
     *      type: 'Equals',
     *      subject: 'nameOfVersionAttribute',
     *      object: currentVersion
     *  };
     *
     *  const updated = await mapper.executeUpdateExpression(
     *      updateExpression,
     *      itemKey,
     *      constructor,
     *      {condition}
     *  );
     * ```
     *
     * **NB:** Property names and attribute paths in the update expression
     * should reflect the names used in the schema.
     *
     * @param expression        The update expression to execute.
     * @param key               The full key to identify the object being
     *                          updated.
     * @param valueConstructor  The constructor with which to map the result to
     *                          a domain object.
     * @param options           Options with which to customize the UpdateItem
     *                          request.
     *
     * @returns The updated item.
     */
    executeUpdateExpression(expression, key, valueConstructor, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.doExecuteUpdateExpression(expression, key, getSchema(valueConstructor.prototype), getTableName(valueConstructor.prototype), valueConstructor, options);
        });
    }
    doExecuteUpdateExpression(expression, key, schema, tableName, valueConstructor, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                TableName: this.tableNamePrefix + tableName,
                ReturnValues: 'ALL_NEW',
                Key: marshallKey(schema, key),
            };
            const attributes = new ExpressionAttributes();
            if (options.condition) {
                req.ConditionExpression = marshallConditionExpression(options.condition, schema, attributes).expression;
            }
            req.UpdateExpression = marshallUpdateExpression(expression, schema, attributes).expression;
            if (Object.keys(attributes.names).length > 0) {
                req.ExpressionAttributeNames = attributes.names;
            }
            if (Object.keys(attributes.values).length > 0) {
                req.ExpressionAttributeValues = attributes.values;
            }
            const rawResponse = yield this.client.updateItem(req);
            if (rawResponse.Attributes) {
                return unmarshallItem(schema, rawResponse.Attributes, valueConstructor);
            }
            // this branch should not be reached when interacting with DynamoDB, as
            // the ReturnValues parameter is hardcoded to 'ALL_NEW' above. It is,
            // however, allowed by the service model and may therefore occur in
            // certain unforeseen conditions; to be safe, this case should be
            // converted into an error unless a compelling reason to return
            // undefined or an empty object presents itself.
            throw new Error('Update operation completed successfully, but the updated value was not returned');
        });
    }
    getTableName(item) {
        return getTableName(item, this.tableNamePrefix);
    }
    mapGetBatch(items, state, options, convertedOptions) {
        return __asyncGenerator(this, arguments, function* mapGetBatch_1() {
            var e_7, _a;
            try {
                for (var items_3 = __asyncValues(items), items_3_1; items_3_1 = yield __await(items_3.next()), !items_3_1.done;) {
                    const item = items_3_1.value;
                    const unprefixed = getTableName(item);
                    const tableName = this.tableNamePrefix + unprefixed;
                    const schema = getSchema(item);
                    if (unprefixed in options && !(tableName in convertedOptions)) {
                        convertedOptions[tableName] = convertBatchGetOptions(options[unprefixed], schema);
                    }
                    if (!(tableName in state)) {
                        state[tableName] = {
                            keyProperties: getKeyProperties(schema),
                            itemSchemata: {}
                        };
                    }
                    const { keyProperties, itemSchemata } = state[tableName];
                    const marshalled = marshallKey(schema, item);
                    itemSchemata[itemIdentifier(marshalled, keyProperties)] = {
                        constructor: item.constructor,
                        schema,
                    };
                    yield yield __await([tableName, marshalled]);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (items_3_1 && !items_3_1.done && (_a = items_3.return)) yield __await(_a.call(items_3));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    mapWriteBatch(items, state) {
        return __asyncGenerator(this, arguments, function* mapWriteBatch_1() {
            var e_8, _a;
            try {
                for (var items_4 = __asyncValues(items), items_4_1; items_4_1 = yield __await(items_4.next()), !items_4_1.done;) {
                    const [type, item] = items_4_1.value;
                    const unprefixed = getTableName(item);
                    const tableName = this.tableNamePrefix + unprefixed;
                    const schema = getSchema(item);
                    if (!(tableName in state)) {
                        state[tableName] = {
                            keyProperties: getKeyProperties(schema),
                            itemSchemata: {}
                        };
                    }
                    const { keyProperties, itemSchemata } = state[tableName];
                    const attributes = type === 'delete'
                        ? marshallKey(schema, item)
                        : marshallItem(schema, item);
                    const marshalled = type === 'delete'
                        ? { DeleteRequest: { Key: attributes } }
                        : { PutRequest: { Item: attributes } };
                    itemSchemata[itemIdentifier(attributes, keyProperties)] = {
                        constructor: item.constructor,
                        schema,
                    };
                    yield yield __await([tableName, marshalled]);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (items_4_1 && !items_4_1.done && (_a = items_4.return)) yield __await(_a.call(items_4));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
}
function attributeDefinitionList(attributes) {
    return Object.keys(attributes).map(name => ({
        AttributeName: name,
        AttributeType: attributes[name]
    }));
}
function convertBatchGetOptions(options, itemSchema) {
    const out = {};
    if (options.readConsistency === 'strong') {
        out.ConsistentRead = true;
    }
    if (options.projection) {
        const attributes = new ExpressionAttributes();
        out.ProjectionExpression = serializeProjectionExpression(options.projection.map(propName => toSchemaName(propName, options.projectionSchema || itemSchema)), attributes);
        out.ExpressionAttributeNames = attributes.names;
    }
    return out;
}
function getKeyProperties(schema) {
    const keys = [];
    for (const property of Object.keys(schema).sort()) {
        const fieldSchema = schema[property];
        if (isKey(fieldSchema)) {
            keys.push(fieldSchema.attributeName || property);
        }
    }
    return keys;
}
function handleVersionAttribute(attributeName, inputMember) {
    let condition;
    let value;
    if (inputMember === undefined) {
        condition = new FunctionExpression('attribute_not_exists', new AttributePath([
            { type: 'AttributeName', name: attributeName }
        ]));
        value = new AttributeValueClass({ N: "0" });
    }
    else {
        condition = {
            type: 'Equals',
            subject: attributeName,
            object: inputMember,
        };
        value = new MathematicalExpression(new AttributePath(attributeName), '+', 1);
    }
    return { condition, value };
}
function indexDefinitions(keys, options, schema) {
    const globalIndices = [];
    const localIndices = [];
    for (const IndexName of Object.keys(keys)) {
        const KeySchema = keyTypesToElementList(keys[IndexName]);
        const indexOptions = options[IndexName];
        if (!indexOptions) {
            throw new Error(`No options provided for ${IndexName} index`);
        }
        const indexInfo = {
            IndexName,
            KeySchema,
            Projection: indexProjection(schema, indexOptions.projection),
        };
        if (indexOptions.type === 'local') {
            localIndices.push(indexInfo);
        }
        else {
            globalIndices.push(Object.assign(Object.assign({}, indexInfo), provisionedThroughput(indexOptions.readCapacityUnits, indexOptions.writeCapacityUnits)));
        }
    }
    return {
        GlobalSecondaryIndexes: globalIndices.length ? globalIndices : void 0,
        LocalSecondaryIndexes: localIndices.length ? localIndices : void 0,
    };
}
function indexProjection(schema, projection) {
    if (typeof projection === 'string') {
        return {
            ProjectionType: projection === 'all' ? 'ALL' : 'KEYS_ONLY',
        };
    }
    return {
        ProjectionType: 'INCLUDE',
        NonKeyAttributes: projection.map(propName => getSchemaName(propName, schema))
    };
}
function isIterable(arg) {
    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
}
function isVersionAttribute(fieldSchema) {
    return fieldSchema.type === 'Number'
        && Boolean(fieldSchema.versionAttribute);
}
function itemIdentifier(marshalled, keyProperties) {
    const keyAttributes = [];
    for (const key of keyProperties) {
        const value = marshalled[key];
        keyAttributes.push(`${key}=${value.B || value.N || value.S}`);
    }
    return keyAttributes.join(':');
}
function keyTypesToElementList(keys) {
    const elementList = Object.keys(keys).map(name => ({
        AttributeName: name,
        KeyType: keys[name]
    }));
    elementList.sort((a, b) => {
        if (a.KeyType === 'HASH' && b.KeyType !== 'HASH') {
            return -1;
        }
        if (a.KeyType !== 'HASH' && b.KeyType === 'HASH') {
            return 1;
        }
        return 0;
    });
    return elementList;
}
function provisionedThroughput(readCapacityUnits, writeCapacityUnits) {
    let capacityUnits;
    if (typeof readCapacityUnits === 'number' && typeof writeCapacityUnits === 'number') {
        capacityUnits = {
            ReadCapacityUnits: readCapacityUnits,
            WriteCapacityUnits: writeCapacityUnits,
        };
    }
    return Object.assign({}, (capacityUnits && { ProvisionedThroughput: capacityUnits }));
}
//# sourceMappingURL=DataMapper.js.map