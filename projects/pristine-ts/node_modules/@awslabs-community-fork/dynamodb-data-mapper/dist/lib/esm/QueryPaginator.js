import { marshallStartKey } from './marshallStartKey';
import { Paginator } from './Paginator';
import { getSchema, getTableName } from './protocols';
import { QueryPaginator as BasePaginator } from '@awslabs-community-fork/dynamodb-query-iterator';
import { marshallConditionExpression, marshallProjectionExpression, } from '@awslabs-community-fork/dynamodb-data-marshaller';
import { ExpressionAttributes, isConditionExpression, isConditionExpressionPredicate, } from '@awslabs-community-fork/dynamodb-expressions';
/**
 * Iterates over each page of items returned by a DynamoDB query until no more
 * pages are available.
 */
export class QueryPaginator extends Paginator {
    constructor(client, valueConstructor, keyCondition, options = {}) {
        const itemSchema = getSchema(valueConstructor.prototype);
        let { filter, indexName, limit, pageSize, projection, readConsistency, scanIndexForward, startKey, tableNamePrefix: prefix, } = options;
        const req = {
            TableName: getTableName(valueConstructor.prototype, prefix),
            ScanIndexForward: scanIndexForward,
            Limit: pageSize,
            IndexName: indexName,
        };
        if (readConsistency === 'strong') {
            req.ConsistentRead = true;
        }
        const attributes = new ExpressionAttributes();
        req.KeyConditionExpression = marshallConditionExpression(normalizeKeyCondition(keyCondition), itemSchema, attributes).expression;
        if (filter) {
            req.FilterExpression = marshallConditionExpression(filter, itemSchema, attributes).expression;
        }
        if (projection) {
            req.ProjectionExpression = marshallProjectionExpression(projection, itemSchema, attributes).expression;
        }
        if (Object.keys(attributes.names).length > 0) {
            req.ExpressionAttributeNames = attributes.names;
        }
        if (Object.keys(attributes.values).length > 0) {
            req.ExpressionAttributeValues = attributes.values;
        }
        if (startKey) {
            req.ExclusiveStartKey = marshallStartKey(itemSchema, startKey);
        }
        super(new BasePaginator(client, req, limit), valueConstructor);
    }
}
function normalizeKeyCondition(keyCondition) {
    if (isConditionExpression(keyCondition)) {
        return keyCondition;
    }
    const conditions = [];
    for (const property of Object.keys(keyCondition)) {
        const predicate = keyCondition[property];
        if (isConditionExpressionPredicate(predicate)) {
            conditions.push(Object.assign(Object.assign({}, predicate), { subject: property }));
        }
        else {
            conditions.push({
                type: 'Equals',
                subject: property,
                object: predicate,
            });
        }
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    return { type: 'And', conditions };
}
//# sourceMappingURL=QueryPaginator.js.map