"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchGet = exports.MAX_READ_BATCH_SIZE = void 0;
const BatchOperation_1 = require("./BatchOperation");
exports.MAX_READ_BATCH_SIZE = 100;
/**
 * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
 * BatchGetItem operations. The items may be from any number of tables.
 *
 * This method will automatically retry any get requests returned by DynamoDB as
 * unprocessed. Exponential backoff on unprocessed items is employed on a
 * per-table basis.
 */
class BatchGet extends BatchOperation_1.BatchOperation {
    /**
     * @param client    The AWS SDK client with which to communicate with
     *                  DynamoDB.
     * @param items     A synchronous or asynchronous iterable of tuples
     *                  describing the reads to execute. The first member of the
     *                  tuple should be the name of the table from which to
     *                  read, and the second should be the marshalled key.
     * @param options   Additional options to apply to the operations executed.
     */
    constructor(client, items, { ConsistentRead, PerTableOptions = {}, } = {}) {
        super(client, items);
        this.batchSize = exports.MAX_READ_BATCH_SIZE;
        this.error = 0;
        this.success = 0;
        this.consistentRead = ConsistentRead;
        this.options = PerTableOptions;
    }
    doBatchRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            let operationInput = { RequestItems: {} };
            let batchSize = 0;
            while (this.toSend.length > 0) {
                const [tableName, item] = this.toSend.shift();
                if (operationInput.RequestItems === undefined) {
                    operationInput.RequestItems = {};
                }
                if (operationInput.RequestItems[tableName] === undefined) {
                    const { projection, consistentRead, attributeNames, } = this.state[tableName];
                    operationInput.RequestItems[tableName] = {
                        Keys: [],
                        ConsistentRead: consistentRead,
                        ProjectionExpression: projection,
                        ExpressionAttributeNames: attributeNames,
                    };
                }
                // @ts-ignore I can't see why operationInput.RequestItems[tableName].Keys can be undefined
                operationInput.RequestItems[tableName].Keys.push(item);
                if (++batchSize === this.batchSize) {
                    break;
                }
            }
            const { Responses = {}, UnprocessedKeys = {}, } = yield this.client.batchGetItem(operationInput);
            const unprocessedTables = new Set();
            for (const table of Object.keys(UnprocessedKeys)) {
                unprocessedTables.add(table);
                this.error += UnprocessedKeys[table].Keys.length;
                this.handleThrottled(table, UnprocessedKeys[table].Keys);
            }
            this.movePendingToThrottled(unprocessedTables);
            for (const table of Object.keys(Responses)) {
                const tableData = this.state[table];
                tableData.backoffFactor = Math.max(0, tableData.backoffFactor - 1);
                for (const item of Responses[table]) {
                    this.success++;
                    this.pending.push([table, item]);
                }
            }
            const a = 0;
        });
    }
    getInitialTableState(tableName) {
        const { ExpressionAttributeNames, ProjectionExpression, ConsistentRead = this.consistentRead, } = this.options[tableName] || {};
        return Object.assign(Object.assign({}, super.getInitialTableState(tableName)), { attributeNames: ExpressionAttributeNames, projection: ProjectionExpression, consistentRead: ConsistentRead });
    }
}
exports.BatchGet = BatchGet;
//# sourceMappingURL=BatchGet.js.map