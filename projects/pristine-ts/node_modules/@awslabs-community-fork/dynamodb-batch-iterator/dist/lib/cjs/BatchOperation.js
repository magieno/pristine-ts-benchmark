"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchOperation = void 0;
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
class BatchOperation {
    /**
     * @param client    The AWS SDK client with which to communicate with
     *                  DynamoDB.
     * @param items     A synchronous or asynchronous iterable of tuples
     *                  describing the operations to execute. The first member
     *                  of the tuple should be the name of the table targeted by
     *                  the operation.
     */
    constructor(client, items) {
        this.client = client;
        /**
         * Items that have been retrieved and are ready to be returned.
         */
        this.pending = [];
        /**
         * A mapping of table names to table-specific operation state (e.g., the
         * number of throttling events experienced, etc.)
         */
        this.state = {};
        /**
         * Input elements that are prepared for immediate dispatch
         */
        this.toSend = [];
        this.throttled = new Set();
        this.sourceDone = false;
        if (isIterable(items)) {
            this.iterator = items[Symbol.iterator]();
        }
        else {
            this.iterator = items[Symbol.asyncIterator]();
        }
        this.sourceNext = this.iterator.next();
    }
    next() {
        if (this.lastResolved) {
            this.lastResolved = this.lastResolved.then(() => this.getNext());
        }
        else {
            this.lastResolved = this.getNext();
        }
        return this.lastResolved;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    /**
     * Create and return the initial state object for a given DynamoDB table.
     *
     * @param tableName The name of the table whose initial state should be
     *                  returned.
     */
    getInitialTableState(tableName) {
        return {
            backoffFactor: 0,
            name: tableName,
        };
    }
    /**
     * Accept an array of unprocessed items belonging to a single table and
     * re-enqueue it for submission, making sure the appropriate level of
     * backoff is applied to future operations on the same table.
     *
     * @param tableName     The table to which the unprocessed elements belong.
     * @param unprocessed   Elements returned by DynamoDB as not yet processed.
     *                      The elements should not be unmarshalled, but they
     *                      should be reverted to the form used for elements
     *                      that have not yet been sent.
     */
    handleThrottled(tableName, unprocessed) {
        const tableState = this.state[tableName];
        tableState.backoffFactor++;
        if (tableState.tableThrottling) {
            this.throttled.delete(tableState.tableThrottling.backoffWaiter);
            unprocessed.unshift(...tableState.tableThrottling.unprocessed);
        }
        tableState.tableThrottling = {
            unprocessed,
            backoffWaiter: new Promise(resolve => {
                setTimeout(resolve, exponentialBackoff(tableState.backoffFactor), tableState);
            })
        };
        this.throttled.add(tableState.tableThrottling.backoffWaiter);
    }
    /**
     * Iterate over all pending writes and move those targeting throttled tables
     * into the throttled queue.
     *
     * @param unprocessedTables     A set of tables for which some items were
     *                              returned without being processed.
     */
    movePendingToThrottled(unprocessedTables) {
        var _a;
        for (let i = this.toSend.length - 1; i > -1; i--) {
            const [table, attributes] = this.toSend[i];
            if (unprocessedTables.has(table)) {
                (_a = this.state[table].tableThrottling) === null || _a === void 0 ? void 0 : _a.unprocessed.push(attributes);
                this.toSend.splice(i, 1);
            }
        }
    }
    addToSendQueue([tableName, attributes]) {
        if (!this.state[tableName]) {
            this.state[tableName] = this.getInitialTableState(tableName);
        }
        const tableState = this.state[tableName];
        if (tableState.tableThrottling) {
            tableState.tableThrottling.unprocessed.push(attributes);
        }
        else {
            this.toSend.push([tableName, attributes]);
        }
    }
    enqueueThrottled(table) {
        if (table.tableThrottling === undefined) {
            return;
        }
        const { tableThrottling: { backoffWaiter, unprocessed }, } = table;
        if (unprocessed.length > 0) {
            this.toSend.push(...unprocessed.map(attr => [table.name, attr]));
        }
        this.throttled.delete(backoffWaiter);
        delete table.tableThrottling;
    }
    getNext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sourceDone &&
                this.pending.length === 0 &&
                this.toSend.length === 0 &&
                this.throttled.size === 0) {
                return { done: true };
            }
            if (this.pending.length > 0) {
                return {
                    done: false,
                    value: this.pending.shift()
                };
            }
            yield this.refillPending();
            return this.getNext();
        });
    }
    refillPending() {
        return __awaiter(this, void 0, void 0, function* () {
            while (!this.sourceDone &&
                this.toSend.length < this.batchSize) {
                const toProcess = isIteratorResult(this.sourceNext)
                    ? this.sourceNext
                    : yield Promise.race([
                        this.sourceNext,
                        Promise.race(this.throttled)
                    ]);
                if (isIteratorResult(toProcess)) {
                    this.sourceDone = toProcess.done;
                    if (!this.sourceDone) {
                        this.addToSendQueue(toProcess.value);
                        this.sourceNext = this.iterator.next();
                    }
                }
                else {
                    this.enqueueThrottled(toProcess);
                }
            }
            while (this.toSend.length < this.batchSize && this.throttled.size > 0) {
                this.enqueueThrottled(yield Promise.race(this.throttled));
            }
            if (this.toSend.length > 0) {
                yield this.doBatchRequest();
            }
        });
    }
}
exports.BatchOperation = BatchOperation;
function exponentialBackoff(attempts) {
    return Math.floor(Math.random() * Math.pow(2, attempts));
}
function isIterable(arg) {
    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
}
function isIteratorResult(arg) {
    return Boolean(arg) && typeof arg.done === 'boolean';
}
//# sourceMappingURL=BatchOperation.js.map